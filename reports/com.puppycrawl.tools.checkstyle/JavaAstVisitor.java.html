<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavaAstVisitor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle</a> &gt; <span class="el_source">JavaAstVisitor.java</span></div><h1>JavaAstVisitor.java</h1><pre class="source lang-java linenums">///////////////////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code and other text files for adherence to a set of rules.
// Copyright (C) 2001-2024 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
///////////////////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.stream.Collectors;

import org.antlr.v4.runtime.BufferedTokenStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;

import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageLexer;
import com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParser;
import com.puppycrawl.tools.checkstyle.grammar.java.JavaLanguageParserBaseVisitor;
import com.puppycrawl.tools.checkstyle.utils.TokenUtil;

/**
 * Visitor class used to build Checkstyle's Java AST from the parse tree produced by
 * {@link JavaLanguageParser}. In each {@code visit...} method, we visit the children of a node
 * (which correspond to subrules) or create terminal nodes (tokens), and return a subtree as a
 * result.
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;p&gt;The following package declaration:&lt;/p&gt;
 * &lt;pre&gt;
 * package com.puppycrawl.tools.checkstyle;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Will be parsed by the {@code packageDeclaration} rule from {@code JavaLanguageParser.g4}:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * packageDeclaration
 *     : annotations[true] LITERAL_PACKAGE qualifiedName SEMI
 *     ;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * We override the {@code visitPackageDeclaration} method generated by ANTLR in
 * {@link JavaLanguageParser} at
 * {@link JavaAstVisitor#visitPackageDeclaration(JavaLanguageParser.PackageDeclarationContext)}
 * to create a subtree based on the subrules and tokens found in the {@code packageDeclaration}
 * subrule accordingly, thus producing the following AST:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * PACKAGE_DEF -&amp;gt; package
 * |--ANNOTATIONS -&amp;gt; ANNOTATIONS
 * |--DOT -&amp;gt; .
 * |   |--DOT -&amp;gt; .
 * |   |   |--DOT -&amp;gt; .
 * |   |   |   |--IDENT -&amp;gt; com
 * |   |   |   `--IDENT -&amp;gt; puppycrawl
 * |   |   `--IDENT -&amp;gt; tools
 * |   `--IDENT -&amp;gt; checkstyle
 * `--SEMI -&amp;gt; ;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * See &lt;a href=&quot;https://github.com/checkstyle/checkstyle/pull/10434&quot;&gt;#10434&lt;/a&gt;
 * for a good example of how
 * to make changes to Checkstyle's grammar and AST.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The order of {@code visit...} methods in {@code JavaAstVisitor.java} and production rules in
 * {@code JavaLanguageParser.g4} should be consistent to ease maintenance.
 * &lt;/p&gt;
 */
public final class JavaAstVisitor extends JavaLanguageParserBaseVisitor&lt;DetailAstImpl&gt; {

    /** String representation of the left shift operator. */
    private static final String LEFT_SHIFT = &quot;&lt;&lt;&quot;;

    /** String representation of the unsigned right shift operator. */
    private static final String UNSIGNED_RIGHT_SHIFT = &quot;&gt;&gt;&gt;&quot;;

    /** String representation of the right shift operator. */
    private static final String RIGHT_SHIFT = &quot;&gt;&gt;&quot;;

    /**
     * The tokens here are technically expressions, but should
     * not return an EXPR token as their root.
     */
<span class="fc" id="L110">    private static final int[] EXPRESSIONS_WITH_NO_EXPR_ROOT = {</span>
        TokenTypes.CTOR_CALL,
        TokenTypes.SUPER_CTOR_CALL,
        TokenTypes.LAMBDA,
    };

    /** Token stream to check for hidden tokens. */
    private final BufferedTokenStream tokens;

    /**
     * Constructs a JavaAstVisitor with given token stream.
     *
     * @param tokenStream the token stream to check for hidden tokens
     */
<span class="fc" id="L124">    public JavaAstVisitor(CommonTokenStream tokenStream) {</span>
<span class="fc" id="L125">        tokens = tokenStream;</span>
<span class="fc" id="L126">    }</span>

    @Override
    public DetailAstImpl visitCompilationUnit(JavaLanguageParser.CompilationUnitContext ctx) {
        final DetailAstImpl compilationUnit;
        // 'EOF' token is always present; therefore if we only have one child, we have an empty file
<span class="fc bfc" id="L132" title="All 2 branches covered.">        final boolean isEmptyFile = ctx.children.size() == 1;</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (isEmptyFile) {</span>
<span class="fc" id="L134">            compilationUnit = null;</span>
        }
        else {
<span class="fc" id="L137">            compilationUnit = createImaginary(TokenTypes.COMPILATION_UNIT);</span>
            // last child is 'EOF', we do not include this token in AST
<span class="fc" id="L139">            processChildren(compilationUnit, ctx.children.subList(0, ctx.children.size() - 1));</span>
        }
<span class="fc" id="L141">        return compilationUnit;</span>
    }

    @Override
    public DetailAstImpl visitPackageDeclaration(
            JavaLanguageParser.PackageDeclarationContext ctx) {
<span class="fc" id="L147">        final DetailAstImpl packageDeclaration =</span>
<span class="fc" id="L148">                create(TokenTypes.PACKAGE_DEF, (Token) ctx.LITERAL_PACKAGE().getPayload());</span>
<span class="fc" id="L149">        packageDeclaration.addChild(visit(ctx.annotations()));</span>
<span class="fc" id="L150">        packageDeclaration.addChild(visit(ctx.qualifiedName()));</span>
<span class="fc" id="L151">        packageDeclaration.addChild(create(ctx.SEMI()));</span>
<span class="fc" id="L152">        return packageDeclaration;</span>
    }

    @Override
    public DetailAstImpl visitImportDec(JavaLanguageParser.ImportDecContext ctx) {
<span class="fc" id="L157">        final DetailAstImpl importRoot = create(ctx.start);</span>

        // Static import
<span class="fc" id="L160">        final TerminalNode literalStaticNode = ctx.LITERAL_STATIC();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (literalStaticNode != null) {</span>
<span class="fc" id="L162">            importRoot.setType(TokenTypes.STATIC_IMPORT);</span>
<span class="fc" id="L163">            importRoot.addChild(create(literalStaticNode));</span>
        }

        // Handle star imports
<span class="fc bfc" id="L167" title="All 2 branches covered.">        final boolean isStarImport = ctx.STAR() != null;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (isStarImport) {</span>
<span class="fc" id="L169">            final DetailAstImpl dot = create(ctx.DOT());</span>
<span class="fc" id="L170">            dot.addChild(visit(ctx.qualifiedName()));</span>
<span class="fc" id="L171">            dot.addChild(create(ctx.STAR()));</span>
<span class="fc" id="L172">            importRoot.addChild(dot);</span>
<span class="fc" id="L173">        }</span>
        else {
<span class="fc" id="L175">            importRoot.addChild(visit(ctx.qualifiedName()));</span>
        }

<span class="fc" id="L178">        importRoot.addChild(create(ctx.SEMI()));</span>
<span class="fc" id="L179">        return importRoot;</span>
    }

    @Override
    public DetailAstImpl visitSingleSemiImport(JavaLanguageParser.SingleSemiImportContext ctx) {
<span class="fc" id="L184">        return create(ctx.SEMI());</span>
    }

    @Override
    public DetailAstImpl visitTypeDeclaration(JavaLanguageParser.TypeDeclarationContext ctx) {
        final DetailAstImpl typeDeclaration;
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (ctx.type == null) {</span>
<span class="fc" id="L191">            typeDeclaration = create(ctx.semi.get(0));</span>
<span class="fc" id="L192">            ctx.semi.subList(1, ctx.semi.size())</span>
<span class="fc" id="L193">                    .forEach(semi -&gt; addLastSibling(typeDeclaration, create(semi)));</span>
        }
        else {
<span class="fc" id="L196">            typeDeclaration = visit(ctx.type);</span>
        }
<span class="fc" id="L198">        return typeDeclaration;</span>
    }

    @Override
    public DetailAstImpl visitModifier(JavaLanguageParser.ModifierContext ctx) {
<span class="fc" id="L203">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitVariableModifier(JavaLanguageParser.VariableModifierContext ctx) {
<span class="fc" id="L208">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitClassDeclaration(JavaLanguageParser.ClassDeclarationContext ctx) {
<span class="fc" id="L213">        return createTypeDeclaration(ctx, TokenTypes.CLASS_DEF, ctx.mods);</span>
    }

    @Override
    public DetailAstImpl visitRecordDeclaration(JavaLanguageParser.RecordDeclarationContext ctx) {
<span class="fc" id="L218">        return createTypeDeclaration(ctx, TokenTypes.RECORD_DEF, ctx.mods);</span>
    }

    @Override
    public DetailAstImpl visitRecordComponentsList(
            JavaLanguageParser.RecordComponentsListContext ctx) {
<span class="fc" id="L224">        final DetailAstImpl lparen = create(ctx.LPAREN());</span>

        // We make a &quot;RECORD_COMPONENTS&quot; node whether components exist or not
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (ctx.recordComponents() == null) {</span>
<span class="fc" id="L228">            addLastSibling(lparen, createImaginary(TokenTypes.RECORD_COMPONENTS));</span>
        }
        else {
<span class="fc" id="L231">            addLastSibling(lparen, visit(ctx.recordComponents()));</span>
        }
<span class="fc" id="L233">        addLastSibling(lparen, create(ctx.RPAREN()));</span>
<span class="fc" id="L234">        return lparen;</span>
    }

    @Override
    public DetailAstImpl visitRecordComponents(JavaLanguageParser.RecordComponentsContext ctx) {
<span class="fc" id="L239">        final DetailAstImpl recordComponents = createImaginary(TokenTypes.RECORD_COMPONENTS);</span>
<span class="fc" id="L240">        processChildren(recordComponents, ctx.children);</span>
<span class="fc" id="L241">        return recordComponents;</span>
    }

    @Override
    public DetailAstImpl visitRecordComponent(JavaLanguageParser.RecordComponentContext ctx) {
<span class="fc" id="L246">        final DetailAstImpl recordComponent = createImaginary(TokenTypes.RECORD_COMPONENT_DEF);</span>
<span class="fc" id="L247">        processChildren(recordComponent, ctx.children);</span>
<span class="fc" id="L248">        return recordComponent;</span>
    }

    @Override
    public DetailAstImpl visitLastRecordComponent(
            JavaLanguageParser.LastRecordComponentContext ctx) {
<span class="fc" id="L254">        final DetailAstImpl recordComponent = createImaginary(TokenTypes.RECORD_COMPONENT_DEF);</span>
<span class="fc" id="L255">        processChildren(recordComponent, ctx.children);</span>
<span class="fc" id="L256">        return recordComponent;</span>
    }

    @Override
    public DetailAstImpl visitRecordBody(JavaLanguageParser.RecordBodyContext ctx) {
<span class="fc" id="L261">        final DetailAstImpl objBlock = createImaginary(TokenTypes.OBJBLOCK);</span>
<span class="fc" id="L262">        processChildren(objBlock, ctx.children);</span>
<span class="fc" id="L263">        return objBlock;</span>
    }

    @Override
    public DetailAstImpl visitCompactConstructorDeclaration(
            JavaLanguageParser.CompactConstructorDeclarationContext ctx) {
<span class="fc" id="L269">        final DetailAstImpl compactConstructor = createImaginary(TokenTypes.COMPACT_CTOR_DEF);</span>
<span class="fc" id="L270">        compactConstructor.addChild(createModifiers(ctx.mods));</span>
<span class="fc" id="L271">        compactConstructor.addChild(visit(ctx.id()));</span>
<span class="fc" id="L272">        compactConstructor.addChild(visit(ctx.constructorBlock()));</span>
<span class="fc" id="L273">        return compactConstructor;</span>
    }

    @Override
    public DetailAstImpl visitClassExtends(JavaLanguageParser.ClassExtendsContext ctx) {
<span class="fc" id="L278">        final DetailAstImpl classExtends = create(ctx.EXTENDS_CLAUSE());</span>
<span class="fc" id="L279">        classExtends.addChild(visit(ctx.type));</span>
<span class="fc" id="L280">        return classExtends;</span>
    }

    @Override
    public DetailAstImpl visitImplementsClause(JavaLanguageParser.ImplementsClauseContext ctx) {
<span class="fc" id="L285">        final DetailAstImpl classImplements = create(TokenTypes.IMPLEMENTS_CLAUSE,</span>
<span class="fc" id="L286">                (Token) ctx.LITERAL_IMPLEMENTS().getPayload());</span>
<span class="fc" id="L287">        classImplements.addChild(visit(ctx.typeList()));</span>
<span class="fc" id="L288">        return classImplements;</span>
    }

    @Override
    public DetailAstImpl visitTypeParameters(JavaLanguageParser.TypeParametersContext ctx) {
<span class="fc" id="L293">        final DetailAstImpl typeParameters = createImaginary(TokenTypes.TYPE_PARAMETERS);</span>
<span class="fc" id="L294">        typeParameters.addChild(create(TokenTypes.GENERIC_START, (Token) ctx.LT().getPayload()));</span>
        // Exclude '&lt;' and '&gt;'
<span class="fc" id="L296">        processChildren(typeParameters, ctx.children.subList(1, ctx.children.size() - 1));</span>
<span class="fc" id="L297">        typeParameters.addChild(create(TokenTypes.GENERIC_END, (Token) ctx.GT().getPayload()));</span>
<span class="fc" id="L298">        return typeParameters;</span>
    }

    @Override
    public DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {
<span class="fc" id="L303">        final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);</span>
<span class="fc" id="L304">        processChildren(typeParameter, ctx.children);</span>
<span class="fc" id="L305">        return typeParameter;</span>
    }

    @Override
    public DetailAstImpl visitTypeUpperBounds(JavaLanguageParser.TypeUpperBoundsContext ctx) {
        // In this case, we call 'extends` TYPE_UPPER_BOUNDS
<span class="fc" id="L311">        final DetailAstImpl typeUpperBounds = create(TokenTypes.TYPE_UPPER_BOUNDS,</span>
<span class="fc" id="L312">                (Token) ctx.EXTENDS_CLAUSE().getPayload());</span>
        // 'extends' is child[0]
<span class="fc" id="L314">        processChildren(typeUpperBounds, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L315">        return typeUpperBounds;</span>
    }

    @Override
    public DetailAstImpl visitTypeBound(JavaLanguageParser.TypeBoundContext ctx) {
<span class="fc" id="L320">        final DetailAstImpl typeBoundType = visit(ctx.typeBoundType(0));</span>
<span class="fc" id="L321">        final Iterator&lt;JavaLanguageParser.TypeBoundTypeContext&gt; typeBoundTypeIterator =</span>
<span class="fc" id="L322">                ctx.typeBoundType().listIterator(1);</span>
<span class="fc" id="L323">        ctx.BAND().forEach(band -&gt; {</span>
<span class="fc" id="L324">            addLastSibling(typeBoundType, create(TokenTypes.TYPE_EXTENSION_AND,</span>
<span class="fc" id="L325">                                (Token) band.getPayload()));</span>
<span class="fc" id="L326">            addLastSibling(typeBoundType, visit(typeBoundTypeIterator.next()));</span>
<span class="fc" id="L327">        });</span>
<span class="fc" id="L328">        return typeBoundType;</span>
    }

    @Override
    public DetailAstImpl visitTypeBoundType(JavaLanguageParser.TypeBoundTypeContext ctx) {
<span class="fc" id="L333">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitEnumDeclaration(JavaLanguageParser.EnumDeclarationContext ctx) {
<span class="fc" id="L338">        return createTypeDeclaration(ctx, TokenTypes.ENUM_DEF, ctx.mods);</span>
    }

    @Override
    public DetailAstImpl visitEnumBody(JavaLanguageParser.EnumBodyContext ctx) {
<span class="fc" id="L343">        final DetailAstImpl objBlock = createImaginary(TokenTypes.OBJBLOCK);</span>
<span class="fc" id="L344">        processChildren(objBlock, ctx.children);</span>
<span class="fc" id="L345">        return objBlock;</span>
    }

    @Override
    public DetailAstImpl visitEnumConstants(JavaLanguageParser.EnumConstantsContext ctx) {
<span class="fc" id="L350">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitEnumConstant(JavaLanguageParser.EnumConstantContext ctx) {
<span class="fc" id="L355">        final DetailAstImpl enumConstant =</span>
<span class="fc" id="L356">                createImaginary(TokenTypes.ENUM_CONSTANT_DEF);</span>
<span class="fc" id="L357">        processChildren(enumConstant, ctx.children);</span>
<span class="fc" id="L358">        return enumConstant;</span>
    }

    @Override
    public DetailAstImpl visitEnumBodyDeclarations(
            JavaLanguageParser.EnumBodyDeclarationsContext ctx) {
<span class="fc" id="L364">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitInterfaceDeclaration(
            JavaLanguageParser.InterfaceDeclarationContext ctx) {
<span class="fc" id="L370">        return createTypeDeclaration(ctx, TokenTypes.INTERFACE_DEF, ctx.mods);</span>
    }

    @Override
    public DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {
<span class="fc" id="L375">        final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());</span>
<span class="fc" id="L376">        interfaceExtends.addChild(visit(ctx.typeList()));</span>
<span class="fc" id="L377">        return interfaceExtends;</span>
    }

    @Override
    public DetailAstImpl visitClassBody(JavaLanguageParser.ClassBodyContext ctx) {
<span class="fc" id="L382">        final DetailAstImpl objBlock = createImaginary(TokenTypes.OBJBLOCK);</span>
<span class="fc" id="L383">        processChildren(objBlock, ctx.children);</span>
<span class="fc" id="L384">        return objBlock;</span>
    }

    @Override
    public DetailAstImpl visitInterfaceBody(JavaLanguageParser.InterfaceBodyContext ctx) {
<span class="fc" id="L389">        final DetailAstImpl objBlock = createImaginary(TokenTypes.OBJBLOCK);</span>
<span class="fc" id="L390">        processChildren(objBlock, ctx.children);</span>
<span class="fc" id="L391">        return objBlock;</span>
    }

    @Override
    public DetailAstImpl visitEmptyClass(JavaLanguageParser.EmptyClassContext ctx) {
<span class="fc" id="L396">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitClassBlock(JavaLanguageParser.ClassBlockContext ctx) {
        final DetailAstImpl classBlock;
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (ctx.LITERAL_STATIC() == null) {</span>
            // We call it an INSTANCE_INIT
<span class="fc" id="L404">            classBlock = createImaginary(TokenTypes.INSTANCE_INIT);</span>
        }
        else {
<span class="fc" id="L407">            classBlock = create(TokenTypes.STATIC_INIT, (Token) ctx.LITERAL_STATIC().getPayload());</span>
<span class="fc" id="L408">            classBlock.setText(TokenUtil.getTokenName(TokenTypes.STATIC_INIT));</span>
        }
<span class="fc" id="L410">        classBlock.addChild(visit(ctx.block()));</span>
<span class="fc" id="L411">        return classBlock;</span>
    }

    @Override
    public DetailAstImpl visitMethodDeclaration(JavaLanguageParser.MethodDeclarationContext ctx) {
<span class="fc" id="L416">        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);</span>
<span class="fc" id="L417">        methodDef.addChild(createModifiers(ctx.mods));</span>

        // Process all children except C style array declarators
<span class="fc" id="L420">        processChildren(methodDef, ctx.children.stream()</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                .filter(child -&gt; !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))</span>
<span class="fc" id="L422">                .collect(Collectors.toList()));</span>

        // We add C style array declarator brackets to TYPE ast
<span class="fc" id="L425">        final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);</span>
<span class="fc" id="L426">        ctx.cStyleArrDec.forEach(child -&gt; typeAst.addChild(visit(child)));</span>

<span class="fc" id="L428">        return methodDef;</span>
    }

    @Override
    public DetailAstImpl visitMethodBody(JavaLanguageParser.MethodBodyContext ctx) {
<span class="fc" id="L433">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitThrowsList(JavaLanguageParser.ThrowsListContext ctx) {
<span class="fc" id="L438">        final DetailAstImpl throwsRoot = create(ctx.LITERAL_THROWS());</span>
<span class="fc" id="L439">        throwsRoot.addChild(visit(ctx.qualifiedNameList()));</span>
<span class="fc" id="L440">        return throwsRoot;</span>
    }

    @Override
    public DetailAstImpl visitConstructorDeclaration(
            JavaLanguageParser.ConstructorDeclarationContext ctx) {
<span class="fc" id="L446">        final DetailAstImpl constructorDeclaration = createImaginary(TokenTypes.CTOR_DEF);</span>
<span class="fc" id="L447">        constructorDeclaration.addChild(createModifiers(ctx.mods));</span>
<span class="fc" id="L448">        processChildren(constructorDeclaration, ctx.children);</span>
<span class="fc" id="L449">        return constructorDeclaration;</span>
    }

    @Override
    public DetailAstImpl visitFieldDeclaration(JavaLanguageParser.FieldDeclarationContext ctx) {
<span class="fc" id="L454">        final DetailAstImpl dummyNode = new DetailAstImpl();</span>
        // Since the TYPE AST is built by visitVariableDeclarator(), we skip it here (child [0])
        // We also append the SEMI token to the first child [size() - 1],
        // until https://github.com/checkstyle/checkstyle/issues/3151
<span class="fc" id="L458">        processChildren(dummyNode, ctx.children.subList(1, ctx.children.size() - 1));</span>
<span class="fc" id="L459">        dummyNode.getFirstChild().addChild(create(ctx.SEMI()));</span>
<span class="fc" id="L460">        return dummyNode.getFirstChild();</span>
    }

    @Override
    public DetailAstImpl visitInterfaceBodyDeclaration(
            JavaLanguageParser.InterfaceBodyDeclarationContext ctx) {
        final DetailAstImpl returnTree;
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (ctx.SEMI() == null) {</span>
<span class="fc" id="L468">            returnTree = visit(ctx.interfaceMemberDeclaration());</span>
        }
        else {
<span class="fc" id="L471">            returnTree = create(ctx.SEMI());</span>
        }
<span class="fc" id="L473">        return returnTree;</span>
    }

    @Override
    public DetailAstImpl visitInterfaceMethodDeclaration(
            JavaLanguageParser.InterfaceMethodDeclarationContext ctx) {
<span class="fc" id="L479">        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);</span>
<span class="fc" id="L480">        methodDef.addChild(createModifiers(ctx.mods));</span>

        // Process all children except C style array declarators and modifiers
<span class="fc" id="L483">        final List&lt;ParseTree&gt; children = ctx.children</span>
<span class="fc" id="L484">                .stream()</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">                .filter(child -&gt; !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))</span>
<span class="fc" id="L486">                .collect(Collectors.toList());</span>
<span class="fc" id="L487">        processChildren(methodDef, children);</span>

        // We add C style array declarator brackets to TYPE ast
<span class="fc" id="L490">        final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);</span>
<span class="fc" id="L491">        ctx.cStyleArrDec.forEach(child -&gt; typeAst.addChild(visit(child)));</span>

<span class="fc" id="L493">        return methodDef;</span>
    }

    @Override
    public DetailAstImpl visitVariableDeclarators(
            JavaLanguageParser.VariableDeclaratorsContext ctx) {
<span class="fc" id="L499">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitVariableDeclarator(
            JavaLanguageParser.VariableDeclaratorContext ctx) {
<span class="fc" id="L505">        final DetailAstImpl variableDef = createImaginary(TokenTypes.VARIABLE_DEF);</span>
<span class="fc" id="L506">        variableDef.addChild(createModifiers(ctx.mods));</span>

<span class="fc" id="L508">        final DetailAstImpl type = visit(ctx.type);</span>
<span class="fc" id="L509">        variableDef.addChild(type);</span>
<span class="fc" id="L510">        variableDef.addChild(visit(ctx.id()));</span>

        // Add C style array declarator brackets to TYPE ast
<span class="fc" id="L513">        ctx.arrayDeclarator().forEach(child -&gt; type.addChild(visit(child)));</span>

        // If this is an assignment statement, ASSIGN becomes the parent of EXPR
<span class="fc" id="L516">        final TerminalNode assignNode = ctx.ASSIGN();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (assignNode != null) {</span>
<span class="fc" id="L518">            final DetailAstImpl assign = create(assignNode);</span>
<span class="fc" id="L519">            variableDef.addChild(assign);</span>
<span class="fc" id="L520">            assign.addChild(visit(ctx.variableInitializer()));</span>
        }
<span class="fc" id="L522">        return variableDef;</span>
    }

    @Override
    public DetailAstImpl visitVariableDeclaratorId(
            JavaLanguageParser.VariableDeclaratorIdContext ctx) {
<span class="fc" id="L528">        final DetailAstImpl root = new DetailAstImpl();</span>
<span class="fc" id="L529">        root.addChild(createModifiers(ctx.mods));</span>
<span class="fc" id="L530">        final DetailAstImpl type = visit(ctx.type);</span>
<span class="fc" id="L531">        root.addChild(type);</span>

        final DetailAstImpl declaratorId;
<span class="fc bfc" id="L534" title="All 2 branches covered.">        if (ctx.LITERAL_THIS() == null) {</span>
<span class="fc" id="L535">            declaratorId = visit(ctx.qualifiedName());</span>
        }
<span class="fc bfc" id="L537" title="All 2 branches covered.">        else if (ctx.DOT() == null) {</span>
<span class="fc" id="L538">            declaratorId = create(ctx.LITERAL_THIS());</span>
        }
        else {
<span class="fc" id="L541">            declaratorId = create(ctx.DOT());</span>
<span class="fc" id="L542">            declaratorId.addChild(visit(ctx.qualifiedName()));</span>
<span class="fc" id="L543">            declaratorId.addChild(create(ctx.LITERAL_THIS()));</span>
        }

<span class="fc" id="L546">        root.addChild(declaratorId);</span>
<span class="fc" id="L547">        ctx.arrayDeclarator().forEach(child -&gt; type.addChild(visit(child)));</span>

<span class="fc" id="L549">        return root.getFirstChild();</span>
    }

    @Override
    public DetailAstImpl visitArrayInitializer(JavaLanguageParser.ArrayInitializerContext ctx) {
<span class="fc" id="L554">        final DetailAstImpl arrayInitializer = create(TokenTypes.ARRAY_INIT, ctx.start);</span>
        // ARRAY_INIT was child[0]
<span class="fc" id="L556">        processChildren(arrayInitializer, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L557">        return arrayInitializer;</span>
    }

    @Override
    public DetailAstImpl visitClassOrInterfaceType(
            JavaLanguageParser.ClassOrInterfaceTypeContext ctx) {
<span class="fc" id="L563">        final DetailAstPair currentAST = new DetailAstPair();</span>
<span class="fc" id="L564">        DetailAstPair.addAstChild(currentAST, visit(ctx.id()));</span>
<span class="fc" id="L565">        DetailAstPair.addAstChild(currentAST, visit(ctx.typeArguments()));</span>

        // This is how we build the annotations/ qualified name/ type parameters tree
<span class="fc bfc" id="L568" title="All 2 branches covered.">        for (ParserRuleContext extendedContext : ctx.extended) {</span>
<span class="fc" id="L569">            final DetailAstImpl dot = create(extendedContext.start);</span>
<span class="fc" id="L570">            DetailAstPair.makeAstRoot(currentAST, dot);</span>
<span class="fc" id="L571">            extendedContext.children</span>
<span class="fc" id="L572">                .forEach(child -&gt; DetailAstPair.addAstChild(currentAST, visit(child)));</span>
<span class="fc" id="L573">        }</span>

        // Create imaginary 'TYPE' parent if specified
        final DetailAstImpl returnTree;
<span class="fc bfc" id="L577" title="All 2 branches covered.">        if (ctx.createImaginaryNode) {</span>
<span class="fc" id="L578">            returnTree = createImaginary(TokenTypes.TYPE);</span>
<span class="fc" id="L579">            returnTree.addChild(currentAST.root);</span>
        }
        else {
<span class="fc" id="L582">            returnTree = currentAST.root;</span>
        }
<span class="fc" id="L584">        return returnTree;</span>
    }

    @Override
    public DetailAstImpl visitSimpleTypeArgument(
            JavaLanguageParser.SimpleTypeArgumentContext ctx) {
<span class="fc" id="L590">        final DetailAstImpl typeArgument =</span>
<span class="fc" id="L591">                createImaginary(TokenTypes.TYPE_ARGUMENT);</span>
<span class="fc" id="L592">        typeArgument.addChild(visit(ctx.typeType()));</span>
<span class="fc" id="L593">        return typeArgument;</span>
    }

    @Override
    public DetailAstImpl visitWildCardTypeArgument(
            JavaLanguageParser.WildCardTypeArgumentContext ctx) {
<span class="fc" id="L599">        final DetailAstImpl typeArgument = createImaginary(TokenTypes.TYPE_ARGUMENT);</span>
<span class="fc" id="L600">        typeArgument.addChild(visit(ctx.annotations()));</span>
<span class="fc" id="L601">        typeArgument.addChild(create(TokenTypes.WILDCARD_TYPE,</span>
<span class="fc" id="L602">                (Token) ctx.QUESTION().getPayload()));</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (ctx.upperBound != null) {</span>
<span class="fc" id="L605">            final DetailAstImpl upperBound = create(TokenTypes.TYPE_UPPER_BOUNDS, ctx.upperBound);</span>
<span class="fc" id="L606">            upperBound.addChild(visit(ctx.typeType()));</span>
<span class="fc" id="L607">            typeArgument.addChild(upperBound);</span>
<span class="fc" id="L608">        }</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">        else if (ctx.lowerBound != null) {</span>
<span class="fc" id="L610">            final DetailAstImpl lowerBound = create(TokenTypes.TYPE_LOWER_BOUNDS, ctx.lowerBound);</span>
<span class="fc" id="L611">            lowerBound.addChild(visit(ctx.typeType()));</span>
<span class="fc" id="L612">            typeArgument.addChild(lowerBound);</span>
        }

<span class="fc" id="L615">        return typeArgument;</span>
    }

    @Override
    public DetailAstImpl visitQualifiedNameList(JavaLanguageParser.QualifiedNameListContext ctx) {
<span class="fc" id="L620">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitFormalParameters(JavaLanguageParser.FormalParametersContext ctx) {
<span class="fc" id="L625">        final DetailAstImpl lparen = create(ctx.LPAREN());</span>

        // We make a &quot;PARAMETERS&quot; node whether parameters exist or not
<span class="fc bfc" id="L628" title="All 2 branches covered.">        if (ctx.formalParameterList() == null) {</span>
<span class="fc" id="L629">            addLastSibling(lparen, createImaginary(TokenTypes.PARAMETERS));</span>
        }
        else {
<span class="fc" id="L632">            addLastSibling(lparen, visit(ctx.formalParameterList()));</span>
        }
<span class="fc" id="L634">        addLastSibling(lparen, create(ctx.RPAREN()));</span>
<span class="fc" id="L635">        return lparen;</span>
    }

    @Override
    public DetailAstImpl visitFormalParameterList(
            JavaLanguageParser.FormalParameterListContext ctx) {
<span class="fc" id="L641">        final DetailAstImpl parameters = createImaginary(TokenTypes.PARAMETERS);</span>
<span class="fc" id="L642">        processChildren(parameters, ctx.children);</span>
<span class="fc" id="L643">        return parameters;</span>
    }

    @Override
    public DetailAstImpl visitFormalParameter(JavaLanguageParser.FormalParameterContext ctx) {
<span class="fc" id="L648">        final DetailAstImpl variableDeclaratorId =</span>
<span class="fc" id="L649">                visitVariableDeclaratorId(ctx.variableDeclaratorId());</span>
<span class="fc" id="L650">        final DetailAstImpl parameterDef = createImaginary(TokenTypes.PARAMETER_DEF);</span>
<span class="fc" id="L651">        parameterDef.addChild(variableDeclaratorId);</span>
<span class="fc" id="L652">        return parameterDef;</span>
    }

    @Override
    public DetailAstImpl visitLastFormalParameter(
            JavaLanguageParser.LastFormalParameterContext ctx) {
<span class="fc" id="L658">        final DetailAstImpl parameterDef =</span>
<span class="fc" id="L659">                createImaginary(TokenTypes.PARAMETER_DEF);</span>
<span class="fc" id="L660">        parameterDef.addChild(visit(ctx.variableDeclaratorId()));</span>
<span class="fc" id="L661">        final DetailAstImpl ident = (DetailAstImpl) parameterDef.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc" id="L662">        ident.addPreviousSibling(create(ctx.ELLIPSIS()));</span>
        // We attach annotations on ellipses in varargs to the 'TYPE' ast
<span class="fc" id="L664">        final DetailAstImpl type = (DetailAstImpl) parameterDef.findFirstToken(TokenTypes.TYPE);</span>
<span class="fc" id="L665">        type.addChild(visit(ctx.annotations()));</span>
<span class="fc" id="L666">        return parameterDef;</span>
    }

    @Override
    public DetailAstImpl visitQualifiedName(JavaLanguageParser.QualifiedNameContext ctx) {
<span class="fc" id="L671">        final DetailAstImpl ast = visit(ctx.id());</span>
<span class="fc" id="L672">        final DetailAstPair currentAst = new DetailAstPair();</span>
<span class="fc" id="L673">        DetailAstPair.addAstChild(currentAst, ast);</span>

<span class="fc bfc" id="L675" title="All 2 branches covered.">        for (ParserRuleContext extendedContext : ctx.extended) {</span>
<span class="fc" id="L676">            final DetailAstImpl dot = create(extendedContext.start);</span>
<span class="fc" id="L677">            DetailAstPair.makeAstRoot(currentAst, dot);</span>
<span class="fc" id="L678">            final List&lt;ParseTree&gt; childList = extendedContext</span>
<span class="fc" id="L679">                    .children.subList(1, extendedContext.children.size());</span>
<span class="fc" id="L680">            processChildren(dot, childList);</span>
<span class="fc" id="L681">        }</span>
<span class="fc" id="L682">        return currentAst.getRoot();</span>
    }

    @Override
    public DetailAstImpl visitLiteral(JavaLanguageParser.LiteralContext ctx) {
<span class="fc" id="L687">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitIntegerLiteral(JavaLanguageParser.IntegerLiteralContext ctx) {
<span class="fc" id="L692">        final int[] longTypes = {</span>
            JavaLanguageLexer.DECIMAL_LITERAL_LONG,
            JavaLanguageLexer.HEX_LITERAL_LONG,
            JavaLanguageLexer.OCT_LITERAL_LONG,
            JavaLanguageLexer.BINARY_LITERAL_LONG,
        };

        final int tokenType;
<span class="fc bfc" id="L700" title="All 2 branches covered.">        if (TokenUtil.isOfType(ctx.start.getType(), longTypes)) {</span>
<span class="fc" id="L701">            tokenType = TokenTypes.NUM_LONG;</span>
        }
        else {
<span class="fc" id="L704">            tokenType = TokenTypes.NUM_INT;</span>
        }

<span class="fc" id="L707">        return create(tokenType, ctx.start);</span>
    }

    @Override
    public DetailAstImpl visitFloatLiteral(JavaLanguageParser.FloatLiteralContext ctx) {
        final DetailAstImpl floatLiteral;
<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (TokenUtil.isOfType(ctx.start.getType(),</span>
                JavaLanguageLexer.DOUBLE_LITERAL, JavaLanguageLexer.HEX_DOUBLE_LITERAL)) {
<span class="fc" id="L715">            floatLiteral = create(TokenTypes.NUM_DOUBLE, ctx.start);</span>
        }
        else {
<span class="fc" id="L718">            floatLiteral = create(TokenTypes.NUM_FLOAT, ctx.start);</span>
        }
<span class="fc" id="L720">        return floatLiteral;</span>
    }

    @Override
    public DetailAstImpl visitTextBlockLiteral(JavaLanguageParser.TextBlockLiteralContext ctx) {
<span class="fc" id="L725">        final DetailAstImpl textBlockLiteralBegin = create(ctx.TEXT_BLOCK_LITERAL_BEGIN());</span>
<span class="fc" id="L726">        textBlockLiteralBegin.addChild(create(ctx.TEXT_BLOCK_CONTENT()));</span>
<span class="fc" id="L727">        textBlockLiteralBegin.addChild(create(ctx.TEXT_BLOCK_LITERAL_END()));</span>
<span class="fc" id="L728">        return textBlockLiteralBegin;</span>
    }

    @Override
    public DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {
        final DetailAstImpl annotations;

<span class="fc bfc" id="L735" title="All 4 branches covered.">        if (!ctx.createImaginaryNode &amp;&amp; ctx.anno.isEmpty()) {</span>
            // There are no annotations, and we don't want to create the empty node
<span class="fc" id="L737">            annotations = null;</span>
        }
        else {
            // There are annotations, or we just want the empty node
<span class="fc" id="L741">            annotations = createImaginary(TokenTypes.ANNOTATIONS);</span>
<span class="fc" id="L742">            processChildren(annotations, ctx.anno);</span>
        }

<span class="fc" id="L745">        return annotations;</span>
    }

    @Override
    public DetailAstImpl visitAnnotation(JavaLanguageParser.AnnotationContext ctx) {
<span class="fc" id="L750">        final DetailAstImpl annotation = createImaginary(TokenTypes.ANNOTATION);</span>
<span class="fc" id="L751">        processChildren(annotation, ctx.children);</span>
<span class="fc" id="L752">        return annotation;</span>
    }

    @Override
    public DetailAstImpl visitElementValuePairs(JavaLanguageParser.ElementValuePairsContext ctx) {
<span class="fc" id="L757">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitElementValuePair(JavaLanguageParser.ElementValuePairContext ctx) {
<span class="fc" id="L762">        final DetailAstImpl elementValuePair =</span>
<span class="fc" id="L763">                createImaginary(TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR);</span>
<span class="fc" id="L764">        processChildren(elementValuePair, ctx.children);</span>
<span class="fc" id="L765">        return elementValuePair;</span>
    }

    @Override
    public DetailAstImpl visitElementValue(JavaLanguageParser.ElementValueContext ctx) {
<span class="fc" id="L770">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitElementValueArrayInitializer(
            JavaLanguageParser.ElementValueArrayInitializerContext ctx) {
<span class="fc" id="L776">        final DetailAstImpl arrayInit =</span>
<span class="fc" id="L777">                create(TokenTypes.ANNOTATION_ARRAY_INIT, (Token) ctx.LCURLY().getPayload());</span>
<span class="fc" id="L778">        processChildren(arrayInit, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L779">        return arrayInit;</span>
    }

    @Override
    public DetailAstImpl visitAnnotationTypeDeclaration(
            JavaLanguageParser.AnnotationTypeDeclarationContext ctx) {
<span class="fc" id="L785">        return createTypeDeclaration(ctx, TokenTypes.ANNOTATION_DEF, ctx.mods);</span>
    }

    @Override
    public DetailAstImpl visitAnnotationTypeBody(
            JavaLanguageParser.AnnotationTypeBodyContext ctx) {
<span class="fc" id="L791">        final DetailAstImpl objBlock = createImaginary(TokenTypes.OBJBLOCK);</span>
<span class="fc" id="L792">        processChildren(objBlock, ctx.children);</span>
<span class="fc" id="L793">        return objBlock;</span>
    }

    @Override
    public DetailAstImpl visitAnnotationTypeElementDeclaration(
            JavaLanguageParser.AnnotationTypeElementDeclarationContext ctx) {
        final DetailAstImpl returnTree;
<span class="fc bfc" id="L800" title="All 2 branches covered.">        if (ctx.SEMI() == null) {</span>
<span class="fc" id="L801">            returnTree = visit(ctx.annotationTypeElementRest());</span>
        }
        else {
<span class="fc" id="L804">            returnTree = create(ctx.SEMI());</span>
        }
<span class="fc" id="L806">        return returnTree;</span>
    }

    @Override
    public DetailAstImpl visitAnnotationField(JavaLanguageParser.AnnotationFieldContext ctx) {
<span class="fc" id="L811">        final DetailAstImpl dummyNode = new DetailAstImpl();</span>
        // Since the TYPE AST is built by visitAnnotationMethodOrConstantRest(), we skip it
        // here (child [0])
<span class="fc" id="L814">        processChildren(dummyNode, Collections.singletonList(ctx.children.get(1)));</span>
        // We also append the SEMI token to the first child [size() - 1],
        // until https://github.com/checkstyle/checkstyle/issues/3151
<span class="fc" id="L817">        dummyNode.getFirstChild().addChild(create(ctx.SEMI()));</span>
<span class="fc" id="L818">        return dummyNode.getFirstChild();</span>
    }

    @Override
    public DetailAstImpl visitAnnotationType(JavaLanguageParser.AnnotationTypeContext ctx) {
<span class="fc" id="L823">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitAnnotationMethodRest(
            JavaLanguageParser.AnnotationMethodRestContext ctx) {
<span class="fc" id="L829">        final DetailAstImpl annotationFieldDef =</span>
<span class="fc" id="L830">                createImaginary(TokenTypes.ANNOTATION_FIELD_DEF);</span>
<span class="fc" id="L831">        annotationFieldDef.addChild(createModifiers(ctx.mods));</span>
<span class="fc" id="L832">        annotationFieldDef.addChild(visit(ctx.type));</span>

        // Process all children except C style array declarators
<span class="fc" id="L835">        processChildren(annotationFieldDef, ctx.children.stream()</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                .filter(child -&gt; !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))</span>
<span class="fc" id="L837">                .collect(Collectors.toList()));</span>

        // We add C style array declarator brackets to TYPE ast
<span class="fc" id="L840">        final DetailAstImpl typeAst =</span>
<span class="fc" id="L841">                (DetailAstImpl) annotationFieldDef.findFirstToken(TokenTypes.TYPE);</span>
<span class="fc" id="L842">        ctx.cStyleArrDec.forEach(child -&gt; typeAst.addChild(visit(child)));</span>

<span class="fc" id="L844">        return annotationFieldDef;</span>
    }

    @Override
    public DetailAstImpl visitDefaultValue(JavaLanguageParser.DefaultValueContext ctx) {
<span class="fc" id="L849">        final DetailAstImpl defaultValue = create(ctx.LITERAL_DEFAULT());</span>
<span class="fc" id="L850">        defaultValue.addChild(visit(ctx.elementValue()));</span>
<span class="fc" id="L851">        return defaultValue;</span>
    }

    @Override
    public DetailAstImpl visitConstructorBlock(JavaLanguageParser.ConstructorBlockContext ctx) {
<span class="fc" id="L856">        final DetailAstImpl slist = create(TokenTypes.SLIST, ctx.start);</span>
        // SLIST was child [0]
<span class="fc" id="L858">        processChildren(slist, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L859">        return slist;</span>
    }

    @Override
    public DetailAstImpl visitExplicitCtorCall(JavaLanguageParser.ExplicitCtorCallContext ctx) {
        final DetailAstImpl root;
<span class="fc bfc" id="L865" title="All 2 branches covered.">        if (ctx.LITERAL_THIS() == null) {</span>
<span class="fc" id="L866">            root = create(TokenTypes.SUPER_CTOR_CALL, (Token) ctx.LITERAL_SUPER().getPayload());</span>
        }
        else {
<span class="fc" id="L869">            root = create(TokenTypes.CTOR_CALL, (Token) ctx.LITERAL_THIS().getPayload());</span>
        }
<span class="fc" id="L871">        root.addChild(visit(ctx.typeArguments()));</span>
<span class="fc" id="L872">        root.addChild(visit(ctx.arguments()));</span>
<span class="fc" id="L873">        root.addChild(create(ctx.SEMI()));</span>
<span class="fc" id="L874">        return root;</span>
    }

    @Override
    public DetailAstImpl visitPrimaryCtorCall(JavaLanguageParser.PrimaryCtorCallContext ctx) {
<span class="fc" id="L879">        final DetailAstImpl primaryCtorCall = create(TokenTypes.SUPER_CTOR_CALL,</span>
<span class="fc" id="L880">                (Token) ctx.LITERAL_SUPER().getPayload());</span>
        // filter 'LITERAL_SUPER'
<span class="fc" id="L882">        processChildren(primaryCtorCall, ctx.children.stream()</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">                   .filter(child -&gt; !child.equals(ctx.LITERAL_SUPER()))</span>
<span class="fc" id="L884">                   .collect(Collectors.toList()));</span>
<span class="fc" id="L885">        return primaryCtorCall;</span>
    }

    @Override
    public DetailAstImpl visitBlock(JavaLanguageParser.BlockContext ctx) {
<span class="fc" id="L890">        final DetailAstImpl slist = create(TokenTypes.SLIST, ctx.start);</span>
        // SLIST was child [0]
<span class="fc" id="L892">        processChildren(slist, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L893">        return slist;</span>
    }

    @Override
    public DetailAstImpl visitLocalVar(JavaLanguageParser.LocalVarContext ctx) {
<span class="fc" id="L898">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitBlockStat(JavaLanguageParser.BlockStatContext ctx) {
<span class="fc" id="L903">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitAssertExp(JavaLanguageParser.AssertExpContext ctx) {
<span class="fc" id="L908">        final DetailAstImpl assertExp = create(ctx.ASSERT());</span>
        // child[0] is 'ASSERT'
<span class="fc" id="L910">        processChildren(assertExp, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L911">        return assertExp;</span>
    }

    @Override
    public DetailAstImpl visitIfStat(JavaLanguageParser.IfStatContext ctx) {
<span class="fc" id="L916">        final DetailAstImpl ifStat = create(ctx.LITERAL_IF());</span>
        // child[0] is 'LITERAL_IF'
<span class="fc" id="L918">        processChildren(ifStat, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L919">        return ifStat;</span>
    }

    @Override
    public DetailAstImpl visitForStat(JavaLanguageParser.ForStatContext ctx) {
<span class="fc" id="L924">        final DetailAstImpl forInit = create(ctx.start);</span>
        // child[0] is LITERAL_FOR
<span class="fc" id="L926">        processChildren(forInit, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L927">        return forInit;</span>
    }

    @Override
    public DetailAstImpl visitWhileStat(JavaLanguageParser.WhileStatContext ctx) {
<span class="fc" id="L932">        final DetailAstImpl whileStatement = create(ctx.start);</span>
        // 'LITERAL_WHILE' is child[0]
<span class="fc" id="L934">        processChildren(whileStatement, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L935">        return whileStatement;</span>
    }

    @Override
    public DetailAstImpl visitDoStat(JavaLanguageParser.DoStatContext ctx) {
<span class="fc" id="L940">        final DetailAstImpl doStatement = create(ctx.start);</span>
        // 'LITERAL_DO' is child[0]
<span class="fc" id="L942">        doStatement.addChild(visit(ctx.statement()));</span>
        // We make 'LITERAL_WHILE' into 'DO_WHILE'
<span class="fc" id="L944">        doStatement.addChild(create(TokenTypes.DO_WHILE, (Token) ctx.LITERAL_WHILE().getPayload()));</span>
<span class="fc" id="L945">        doStatement.addChild(visit(ctx.parExpression()));</span>
<span class="fc" id="L946">        doStatement.addChild(create(ctx.SEMI()));</span>
<span class="fc" id="L947">        return doStatement;</span>
    }

    @Override
    public DetailAstImpl visitTryStat(JavaLanguageParser.TryStatContext ctx) {
<span class="fc" id="L952">        final DetailAstImpl tryStat = create(ctx.start);</span>
        // child[0] is 'LITERAL_TRY'
<span class="fc" id="L954">        processChildren(tryStat, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L955">        return tryStat;</span>
    }

    @Override
    public DetailAstImpl visitTryWithResourceStat(
            JavaLanguageParser.TryWithResourceStatContext ctx) {
<span class="fc" id="L961">        final DetailAstImpl tryWithResources = create(ctx.LITERAL_TRY());</span>
        // child[0] is 'LITERAL_TRY'
<span class="fc" id="L963">        processChildren(tryWithResources, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L964">        return tryWithResources;</span>
    }

    @Override
    public DetailAstImpl visitYieldStat(JavaLanguageParser.YieldStatContext ctx) {
<span class="fc" id="L969">        final DetailAstImpl yieldParent = create(ctx.LITERAL_YIELD());</span>
        // LITERAL_YIELD is child[0]
<span class="fc" id="L971">        processChildren(yieldParent, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L972">        return yieldParent;</span>
    }

    @Override
    public DetailAstImpl visitSyncStat(JavaLanguageParser.SyncStatContext ctx) {
<span class="fc" id="L977">        final DetailAstImpl syncStatement = create(ctx.start);</span>
        // child[0] is 'LITERAL_SYNCHRONIZED'
<span class="fc" id="L979">        processChildren(syncStatement, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L980">        return syncStatement;</span>
    }

    @Override
    public DetailAstImpl visitReturnStat(JavaLanguageParser.ReturnStatContext ctx) {
<span class="fc" id="L985">        final DetailAstImpl returnStat = create(ctx.LITERAL_RETURN());</span>
        // child[0] is 'LITERAL_RETURN'
<span class="fc" id="L987">        processChildren(returnStat, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L988">        return returnStat;</span>
    }

    @Override
    public DetailAstImpl visitThrowStat(JavaLanguageParser.ThrowStatContext ctx) {
<span class="fc" id="L993">        final DetailAstImpl throwStat = create(ctx.LITERAL_THROW());</span>
        // child[0] is 'LITERAL_THROW'
<span class="fc" id="L995">        processChildren(throwStat, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L996">        return throwStat;</span>
    }

    @Override
    public DetailAstImpl visitBreakStat(JavaLanguageParser.BreakStatContext ctx) {
<span class="fc" id="L1001">        final DetailAstImpl literalBreak = create(ctx.LITERAL_BREAK());</span>
        // child[0] is 'LITERAL_BREAK'
<span class="fc" id="L1003">        processChildren(literalBreak, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1004">        return literalBreak;</span>
    }

    @Override
    public DetailAstImpl visitContinueStat(JavaLanguageParser.ContinueStatContext ctx) {
<span class="fc" id="L1009">        final DetailAstImpl continueStat = create(ctx.LITERAL_CONTINUE());</span>
        // child[0] is 'LITERAL_CONTINUE'
<span class="fc" id="L1011">        processChildren(continueStat, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1012">        return continueStat;</span>
    }

    @Override
    public DetailAstImpl visitEmptyStat(JavaLanguageParser.EmptyStatContext ctx) {
<span class="fc" id="L1017">        return create(TokenTypes.EMPTY_STAT, ctx.start);</span>
    }

    @Override
    public DetailAstImpl visitExpStat(JavaLanguageParser.ExpStatContext ctx) {
<span class="fc" id="L1022">        final DetailAstImpl expStatRoot = visit(ctx.statementExpression);</span>
<span class="fc" id="L1023">        addLastSibling(expStatRoot, create(ctx.SEMI()));</span>
<span class="fc" id="L1024">        return expStatRoot;</span>
    }

    @Override
    public DetailAstImpl visitLabelStat(JavaLanguageParser.LabelStatContext ctx) {
<span class="fc" id="L1029">        final DetailAstImpl labelStat = create(TokenTypes.LABELED_STAT,</span>
<span class="fc" id="L1030">                (Token) ctx.COLON().getPayload());</span>
<span class="fc" id="L1031">        labelStat.addChild(visit(ctx.id()));</span>
<span class="fc" id="L1032">        labelStat.addChild(visit(ctx.statement()));</span>
<span class="fc" id="L1033">        return labelStat;</span>
    }

    @Override
    public DetailAstImpl visitSwitchExpressionOrStatement(
            JavaLanguageParser.SwitchExpressionOrStatementContext ctx) {
<span class="fc" id="L1039">        final DetailAstImpl switchStat = create(ctx.LITERAL_SWITCH());</span>
<span class="fc" id="L1040">        switchStat.addChild(visit(ctx.parExpression()));</span>
<span class="fc" id="L1041">        switchStat.addChild(create(ctx.LCURLY()));</span>
<span class="fc" id="L1042">        switchStat.addChild(visit(ctx.switchBlock()));</span>
<span class="fc" id="L1043">        switchStat.addChild(create(ctx.RCURLY()));</span>
<span class="fc" id="L1044">        return switchStat;</span>
    }

    @Override
    public DetailAstImpl visitSwitchRules(JavaLanguageParser.SwitchRulesContext ctx) {
<span class="fc" id="L1049">        final DetailAstImpl dummyRoot = new DetailAstImpl();</span>
<span class="fc" id="L1050">        ctx.switchLabeledRule().forEach(switchLabeledRuleContext -&gt; {</span>
<span class="fc" id="L1051">            final DetailAstImpl switchRule = visit(switchLabeledRuleContext);</span>
<span class="fc" id="L1052">            final DetailAstImpl switchRuleParent = createImaginary(TokenTypes.SWITCH_RULE);</span>
<span class="fc" id="L1053">            switchRuleParent.addChild(switchRule);</span>
<span class="fc" id="L1054">            dummyRoot.addChild(switchRuleParent);</span>
<span class="fc" id="L1055">        });</span>
<span class="fc" id="L1056">        return dummyRoot.getFirstChild();</span>
    }

    @Override
    public DetailAstImpl visitSwitchBlocks(JavaLanguageParser.SwitchBlocksContext ctx) {
<span class="fc" id="L1061">        final DetailAstImpl dummyRoot = new DetailAstImpl();</span>
<span class="fc" id="L1062">        ctx.groups.forEach(group -&gt; dummyRoot.addChild(visit(group)));</span>

        // Add any empty switch labels to end of statement in one 'CASE_GROUP'
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (!ctx.emptyLabels.isEmpty()) {</span>
<span class="fc" id="L1066">            final DetailAstImpl emptyLabelParent =</span>
<span class="fc" id="L1067">                    createImaginary(TokenTypes.CASE_GROUP);</span>
<span class="fc" id="L1068">            ctx.emptyLabels.forEach(label -&gt; emptyLabelParent.addChild(visit(label)));</span>
<span class="fc" id="L1069">            dummyRoot.addChild(emptyLabelParent);</span>
        }
<span class="fc" id="L1071">        return dummyRoot.getFirstChild();</span>
    }

    @Override
    public DetailAstImpl visitSwitchLabeledExpression(
            JavaLanguageParser.SwitchLabeledExpressionContext ctx) {
<span class="fc" id="L1077">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitSwitchLabeledBlock(
            JavaLanguageParser.SwitchLabeledBlockContext ctx) {
<span class="fc" id="L1083">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitSwitchLabeledThrow(
            JavaLanguageParser.SwitchLabeledThrowContext ctx) {
<span class="fc" id="L1089">        final DetailAstImpl switchLabel = visit(ctx.switchLabel());</span>
<span class="fc" id="L1090">        addLastSibling(switchLabel, create(ctx.LAMBDA()));</span>
<span class="fc" id="L1091">        final DetailAstImpl literalThrow = create(ctx.LITERAL_THROW());</span>
<span class="fc" id="L1092">        literalThrow.addChild(visit(ctx.expression()));</span>
<span class="fc" id="L1093">        literalThrow.addChild(create(ctx.SEMI()));</span>
<span class="fc" id="L1094">        addLastSibling(switchLabel, literalThrow);</span>
<span class="fc" id="L1095">        return switchLabel;</span>
    }

    @Override
    public DetailAstImpl visitElseStat(JavaLanguageParser.ElseStatContext ctx) {
<span class="fc" id="L1100">        final DetailAstImpl elseStat = create(ctx.LITERAL_ELSE());</span>
        // child[0] is 'LITERAL_ELSE'
<span class="fc" id="L1102">        processChildren(elseStat, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1103">        return elseStat;</span>
    }

    @Override
    public DetailAstImpl visitCatchClause(JavaLanguageParser.CatchClauseContext ctx) {
<span class="fc" id="L1108">        final DetailAstImpl catchClause = create(TokenTypes.LITERAL_CATCH,</span>
<span class="fc" id="L1109">                (Token) ctx.LITERAL_CATCH().getPayload());</span>
        // 'LITERAL_CATCH' is child[0]
<span class="fc" id="L1111">        processChildren(catchClause, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1112">        return catchClause;</span>
    }

    @Override
    public DetailAstImpl visitCatchParameter(JavaLanguageParser.CatchParameterContext ctx) {
<span class="fc" id="L1117">        final DetailAstImpl catchParameterDef = createImaginary(TokenTypes.PARAMETER_DEF);</span>
<span class="fc" id="L1118">        catchParameterDef.addChild(createModifiers(ctx.mods));</span>
        // filter mods
<span class="fc" id="L1120">        processChildren(catchParameterDef, ctx.children.stream()</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">                .filter(child -&gt; !(child instanceof JavaLanguageParser.VariableModifierContext))</span>
<span class="fc" id="L1122">                .collect(Collectors.toList()));</span>
<span class="fc" id="L1123">        return catchParameterDef;</span>
    }

    @Override
    public DetailAstImpl visitCatchType(JavaLanguageParser.CatchTypeContext ctx) {
<span class="fc" id="L1128">        final DetailAstImpl type = createImaginary(TokenTypes.TYPE);</span>
<span class="fc" id="L1129">        processChildren(type, ctx.children);</span>
<span class="fc" id="L1130">        return type;</span>
    }

    @Override
    public DetailAstImpl visitFinallyBlock(JavaLanguageParser.FinallyBlockContext ctx) {
<span class="fc" id="L1135">        final DetailAstImpl finallyBlock = create(ctx.LITERAL_FINALLY());</span>
        // child[0] is 'LITERAL_FINALLY'
<span class="fc" id="L1137">        processChildren(finallyBlock, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1138">        return finallyBlock;</span>
    }

    @Override
    public DetailAstImpl visitResourceSpecification(
            JavaLanguageParser.ResourceSpecificationContext ctx) {
<span class="fc" id="L1144">        final DetailAstImpl resourceSpecification =</span>
<span class="fc" id="L1145">                createImaginary(TokenTypes.RESOURCE_SPECIFICATION);</span>
<span class="fc" id="L1146">        processChildren(resourceSpecification, ctx.children);</span>
<span class="fc" id="L1147">        return resourceSpecification;</span>
    }

    @Override
    public DetailAstImpl visitResources(JavaLanguageParser.ResourcesContext ctx) {
<span class="fc" id="L1152">        final DetailAstImpl firstResource = visit(ctx.resource(0));</span>
<span class="fc" id="L1153">        final DetailAstImpl resources = createImaginary(TokenTypes.RESOURCES);</span>
<span class="fc" id="L1154">        resources.addChild(firstResource);</span>
<span class="fc" id="L1155">        processChildren(resources, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1156">        return resources;</span>
    }

    @Override
    public DetailAstImpl visitResourceDeclaration(
            JavaLanguageParser.ResourceDeclarationContext ctx) {
<span class="fc" id="L1162">        final DetailAstImpl resource = createImaginary(TokenTypes.RESOURCE);</span>
<span class="fc" id="L1163">        resource.addChild(visit(ctx.variableDeclaratorId()));</span>

<span class="fc" id="L1165">        final DetailAstImpl assign = create(ctx.ASSIGN());</span>
<span class="fc" id="L1166">        resource.addChild(assign);</span>
<span class="fc" id="L1167">        assign.addChild(visit(ctx.expression()));</span>
<span class="fc" id="L1168">        return resource;</span>
    }

    @Override
    public DetailAstImpl visitVariableAccess(JavaLanguageParser.VariableAccessContext ctx) {
        final DetailAstImpl resource;
<span class="fc bfc" id="L1174" title="All 2 branches covered.">        if (ctx.accessList.isEmpty()) {</span>
<span class="fc" id="L1175">            resource = createImaginary(TokenTypes.RESOURCE);</span>
<span class="fc" id="L1176">            resource.addChild(visit(ctx.id()));</span>
        }
        else {
<span class="fc" id="L1179">            final DetailAstPair currentAst = new DetailAstPair();</span>
<span class="fc" id="L1180">            ctx.accessList.forEach(fieldAccess -&gt; {</span>
<span class="fc" id="L1181">                DetailAstPair.addAstChild(currentAst, visit(fieldAccess.expr()));</span>
<span class="fc" id="L1182">                DetailAstPair.makeAstRoot(currentAst, create(fieldAccess.DOT()));</span>
<span class="fc" id="L1183">            });</span>
<span class="fc" id="L1184">            resource = createImaginary(TokenTypes.RESOURCE);</span>
<span class="fc" id="L1185">            resource.addChild(currentAst.root);</span>
<span class="fc bfc" id="L1186" title="All 2 branches covered.">            if (ctx.LITERAL_THIS() == null) {</span>
<span class="fc" id="L1187">                resource.getFirstChild().addChild(visit(ctx.id()));</span>
            }
            else {
<span class="fc" id="L1190">                resource.getFirstChild().addChild(create(ctx.LITERAL_THIS()));</span>
            }
        }
<span class="fc" id="L1193">        return resource;</span>
    }

    @Override
    public DetailAstImpl visitSwitchBlockStatementGroup(
            JavaLanguageParser.SwitchBlockStatementGroupContext ctx) {
<span class="fc" id="L1199">        final DetailAstImpl caseGroup = createImaginary(TokenTypes.CASE_GROUP);</span>
<span class="fc" id="L1200">        processChildren(caseGroup, ctx.switchLabel());</span>
<span class="fc" id="L1201">        final DetailAstImpl sList = createImaginary(TokenTypes.SLIST);</span>
<span class="fc" id="L1202">        processChildren(sList, ctx.slists);</span>
<span class="fc" id="L1203">        caseGroup.addChild(sList);</span>
<span class="fc" id="L1204">        return caseGroup;</span>
    }

    @Override
    public DetailAstImpl visitCaseLabel(JavaLanguageParser.CaseLabelContext ctx) {
<span class="fc" id="L1209">        final DetailAstImpl caseLabel = create(ctx.LITERAL_CASE());</span>
        // child [0] is 'LITERAL_CASE'
<span class="fc" id="L1211">        processChildren(caseLabel, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1212">        return caseLabel;</span>
    }

    @Override
    public DetailAstImpl visitDefaultLabel(JavaLanguageParser.DefaultLabelContext ctx) {
<span class="fc" id="L1217">        final DetailAstImpl defaultLabel = create(ctx.LITERAL_DEFAULT());</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">        if (ctx.COLON() != null) {</span>
<span class="fc" id="L1219">            defaultLabel.addChild(create(ctx.COLON()));</span>
        }
<span class="fc" id="L1221">        return defaultLabel;</span>
    }

    @Override
    public DetailAstImpl visitCaseConstants(JavaLanguageParser.CaseConstantsContext ctx) {
<span class="fc" id="L1226">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitCaseConstant(JavaLanguageParser.CaseConstantContext ctx) {
<span class="fc" id="L1231">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitEnhancedFor(JavaLanguageParser.EnhancedForContext ctx) {
<span class="fc" id="L1236">        final DetailAstImpl leftParen = create(ctx.LPAREN());</span>
<span class="fc" id="L1237">        final DetailAstImpl enhancedForControl =</span>
<span class="fc" id="L1238">                 visit(ctx.getChild(1));</span>
<span class="fc" id="L1239">        final DetailAstImpl forEachClause = createImaginary(TokenTypes.FOR_EACH_CLAUSE);</span>
<span class="fc" id="L1240">        forEachClause.addChild(enhancedForControl);</span>
<span class="fc" id="L1241">        addLastSibling(leftParen, forEachClause);</span>
<span class="fc" id="L1242">        addLastSibling(leftParen, create(ctx.RPAREN()));</span>
<span class="fc" id="L1243">        return leftParen;</span>
    }

    @Override
    public DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {
<span class="fc" id="L1248">        final DetailAstImpl dummyRoot = new DetailAstImpl();</span>
<span class="fc" id="L1249">        dummyRoot.addChild(create(ctx.LPAREN()));</span>

<span class="fc bfc" id="L1251" title="All 2 branches covered.">        if (ctx.forInit() == null) {</span>
<span class="fc" id="L1252">            final DetailAstImpl imaginaryForInitParent =</span>
<span class="fc" id="L1253">                    createImaginary(TokenTypes.FOR_INIT);</span>
<span class="fc" id="L1254">            dummyRoot.addChild(imaginaryForInitParent);</span>
<span class="fc" id="L1255">        }</span>
        else {
<span class="fc" id="L1257">            dummyRoot.addChild(visit(ctx.forInit()));</span>
        }

<span class="fc" id="L1260">        dummyRoot.addChild(create(ctx.SEMI(0)));</span>

<span class="fc" id="L1262">        final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);</span>
<span class="fc" id="L1263">        forCondParent.addChild(visit(ctx.forCond));</span>
<span class="fc" id="L1264">        dummyRoot.addChild(forCondParent);</span>
<span class="fc" id="L1265">        dummyRoot.addChild(create(ctx.SEMI(1)));</span>

<span class="fc" id="L1267">        final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);</span>
<span class="fc" id="L1268">        forItParent.addChild(visit(ctx.forUpdate));</span>
<span class="fc" id="L1269">        dummyRoot.addChild(forItParent);</span>

<span class="fc" id="L1271">        dummyRoot.addChild(create(ctx.RPAREN()));</span>

<span class="fc" id="L1273">        return dummyRoot.getFirstChild();</span>
    }

    @Override
    public DetailAstImpl visitForInit(JavaLanguageParser.ForInitContext ctx) {
<span class="fc" id="L1278">        final DetailAstImpl forInit = createImaginary(TokenTypes.FOR_INIT);</span>
<span class="fc" id="L1279">        processChildren(forInit, ctx.children);</span>
<span class="fc" id="L1280">        return forInit;</span>
    }

    @Override
    public DetailAstImpl visitEnhancedForControl(
            JavaLanguageParser.EnhancedForControlContext ctx) {
<span class="fc" id="L1286">        final DetailAstImpl variableDeclaratorId =</span>
<span class="fc" id="L1287">                 visit(ctx.variableDeclaratorId());</span>
<span class="fc" id="L1288">        final DetailAstImpl variableDef = createImaginary(TokenTypes.VARIABLE_DEF);</span>
<span class="fc" id="L1289">        variableDef.addChild(variableDeclaratorId);</span>

<span class="fc" id="L1291">        addLastSibling(variableDef, create(ctx.COLON()));</span>
<span class="fc" id="L1292">        addLastSibling(variableDef, visit(ctx.expression()));</span>
<span class="fc" id="L1293">        return variableDef;</span>
    }

    @Override
    public DetailAstImpl visitEnhancedForControlWithRecordPattern(
            JavaLanguageParser.EnhancedForControlWithRecordPatternContext ctx) {
<span class="fc" id="L1299">        final DetailAstImpl recordPattern =</span>
<span class="fc" id="L1300">                 visit(ctx.pattern());</span>
<span class="fc" id="L1301">        addLastSibling(recordPattern, create(ctx.COLON()));</span>
<span class="fc" id="L1302">        addLastSibling(recordPattern, visit(ctx.expression()));</span>
<span class="fc" id="L1303">        return recordPattern;</span>
    }

    @Override
    public DetailAstImpl visitParExpression(JavaLanguageParser.ParExpressionContext ctx) {
<span class="fc" id="L1308">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitExpressionList(JavaLanguageParser.ExpressionListContext ctx) {
<span class="fc" id="L1313">        final DetailAstImpl elist = createImaginary(TokenTypes.ELIST);</span>
<span class="fc" id="L1314">        processChildren(elist, ctx.children);</span>
<span class="fc" id="L1315">        return elist;</span>
    }

    @Override
    public DetailAstImpl visitExpression(JavaLanguageParser.ExpressionContext ctx) {
<span class="fc" id="L1320">        return buildExpressionNode(ctx.expr());</span>
    }

    @Override
    public DetailAstImpl visitRefOp(JavaLanguageParser.RefOpContext ctx) {
<span class="fc" id="L1325">        final DetailAstImpl bop = create(ctx.bop);</span>
<span class="fc" id="L1326">        final DetailAstImpl leftChild = visit(ctx.expr());</span>
<span class="fc" id="L1327">        final DetailAstImpl rightChild = create(TokenTypes.IDENT, ctx.stop);</span>
<span class="fc" id="L1328">        bop.addChild(leftChild);</span>
<span class="fc" id="L1329">        bop.addChild(rightChild);</span>
<span class="fc" id="L1330">        return bop;</span>
    }

    @Override
    public DetailAstImpl visitSuperExp(JavaLanguageParser.SuperExpContext ctx) {
<span class="fc" id="L1335">        final DetailAstImpl bop = create(ctx.bop);</span>
<span class="fc" id="L1336">        bop.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1337">        bop.addChild(create(ctx.LITERAL_SUPER()));</span>
<span class="fc" id="L1338">        DetailAstImpl superSuffixParent = visit(ctx.superSuffix());</span>

<span class="fc bfc" id="L1340" title="All 2 branches covered.">        if (superSuffixParent == null) {</span>
<span class="fc" id="L1341">            superSuffixParent = bop;</span>
        }
        else {
<span class="fc" id="L1344">            DetailAstImpl firstChild = superSuffixParent;</span>
<span class="fc bfc" id="L1345" title="All 2 branches covered.">            while (firstChild.getFirstChild() != null) {</span>
<span class="fc" id="L1346">                firstChild = firstChild.getFirstChild();</span>
            }
<span class="fc" id="L1348">            firstChild.addPreviousSibling(bop);</span>
        }

<span class="fc" id="L1351">        return superSuffixParent;</span>
    }

    @Override
    public DetailAstImpl visitInstanceOfExp(JavaLanguageParser.InstanceOfExpContext ctx) {
<span class="fc" id="L1356">        final DetailAstImpl literalInstanceOf = create(ctx.LITERAL_INSTANCEOF());</span>
<span class="fc" id="L1357">        literalInstanceOf.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1358">        final ParseTree patternOrType = ctx.getChild(2);</span>

        final DetailAstImpl patternDef;
<span class="fc bfc" id="L1361" title="All 2 branches covered.">        if (patternOrType instanceof JavaLanguageParser.ParenPatternContext) {</span>
            // Parenthesized pattern has a `PATTERN_DEF` parent
<span class="fc" id="L1363">            patternDef = createImaginary(TokenTypes.PATTERN_DEF);</span>
<span class="fc" id="L1364">            patternDef.addChild(visit(patternOrType));</span>
        }
        else {
<span class="fc" id="L1367">            patternDef = visit(patternOrType);</span>
        }
<span class="fc" id="L1369">        literalInstanceOf.addChild(patternDef);</span>
<span class="fc" id="L1370">        return literalInstanceOf;</span>
    }

    @Override
    public DetailAstImpl visitBitShift(JavaLanguageParser.BitShiftContext ctx) {
        final DetailAstImpl shiftOperation;

        // We determine the type of shift operation in the parser, instead of the
        // lexer as in older grammars. This makes it easier to parse type parameters
        // and less than/ greater than operators in general.
<span class="fc bfc" id="L1380" title="All 2 branches covered.">        if (ctx.LT().size() == LEFT_SHIFT.length()) {</span>
<span class="fc" id="L1381">            shiftOperation = create(TokenTypes.SL, (Token) ctx.LT(0).getPayload());</span>
<span class="fc" id="L1382">            shiftOperation.setText(LEFT_SHIFT);</span>
        }
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        else if (ctx.GT().size() == UNSIGNED_RIGHT_SHIFT.length()) {</span>
<span class="fc" id="L1385">            shiftOperation = create(TokenTypes.BSR, (Token) ctx.GT(0).getPayload());</span>
<span class="fc" id="L1386">            shiftOperation.setText(UNSIGNED_RIGHT_SHIFT);</span>
        }
        else {
<span class="fc" id="L1389">            shiftOperation = create(TokenTypes.SR, (Token) ctx.GT(0).getPayload());</span>
<span class="fc" id="L1390">            shiftOperation.setText(RIGHT_SHIFT);</span>
        }

<span class="fc" id="L1393">        shiftOperation.addChild(visit(ctx.expr(0)));</span>
<span class="fc" id="L1394">        shiftOperation.addChild(visit(ctx.expr(1)));</span>
<span class="fc" id="L1395">        return shiftOperation;</span>
    }

    @Override
    public DetailAstImpl visitNewExp(JavaLanguageParser.NewExpContext ctx) {
<span class="fc" id="L1400">        final DetailAstImpl newExp = create(ctx.LITERAL_NEW());</span>
        // child [0] is LITERAL_NEW
<span class="fc" id="L1402">        processChildren(newExp, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1403">        return newExp;</span>
    }

    @Override
    public DetailAstImpl visitPrefix(JavaLanguageParser.PrefixContext ctx) {
        final int tokenType;
<span class="fc bfc" id="L1409" title="All 3 branches covered.">        switch (ctx.prefix.getType()) {</span>
            case JavaLanguageLexer.PLUS:
<span class="fc" id="L1411">                tokenType = TokenTypes.UNARY_PLUS;</span>
<span class="fc" id="L1412">                break;</span>
            case JavaLanguageLexer.MINUS:
<span class="fc" id="L1414">                tokenType = TokenTypes.UNARY_MINUS;</span>
<span class="fc" id="L1415">                break;</span>
            default:
<span class="fc" id="L1417">                tokenType = ctx.prefix.getType();</span>
        }
<span class="fc" id="L1419">        final DetailAstImpl prefix = create(tokenType, ctx.prefix);</span>
<span class="fc" id="L1420">        prefix.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1421">        return prefix;</span>
    }

    @Override
    public DetailAstImpl visitCastExp(JavaLanguageParser.CastExpContext ctx) {
<span class="fc" id="L1426">        final DetailAstImpl cast = create(TokenTypes.TYPECAST, (Token) ctx.LPAREN().getPayload());</span>
        // child [0] is LPAREN
<span class="fc" id="L1428">        processChildren(cast, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L1429">        return cast;</span>
    }

    @Override
    public DetailAstImpl visitIndexOp(JavaLanguageParser.IndexOpContext ctx) {
        // LBRACK -&gt; INDEX_OP is root of this AST
<span class="fc" id="L1435">        final DetailAstImpl indexOp = create(TokenTypes.INDEX_OP,</span>
<span class="fc" id="L1436">                (Token) ctx.LBRACK().getPayload());</span>

        // add expression(IDENT) on LHS
<span class="fc" id="L1439">        indexOp.addChild(visit(ctx.expr(0)));</span>

        // create imaginary node for expression on RHS
<span class="fc" id="L1442">        final DetailAstImpl expr = visit(ctx.expr(1));</span>
<span class="fc" id="L1443">        final DetailAstImpl imaginaryExpr = createImaginary(TokenTypes.EXPR);</span>
<span class="fc" id="L1444">        imaginaryExpr.addChild(expr);</span>
<span class="fc" id="L1445">        indexOp.addChild(imaginaryExpr);</span>

        // complete AST by adding RBRACK
<span class="fc" id="L1448">        indexOp.addChild(create(ctx.RBRACK()));</span>
<span class="fc" id="L1449">        return indexOp;</span>
    }

    @Override
    public DetailAstImpl visitInvOp(JavaLanguageParser.InvOpContext ctx) {
<span class="fc" id="L1454">        final DetailAstPair currentAst = new DetailAstPair();</span>

<span class="fc" id="L1456">        final DetailAstImpl returnAst = visit(ctx.expr());</span>
<span class="fc" id="L1457">        DetailAstPair.addAstChild(currentAst, returnAst);</span>
<span class="fc" id="L1458">        DetailAstPair.makeAstRoot(currentAst, create(ctx.bop));</span>

<span class="fc" id="L1460">        DetailAstPair.addAstChild(currentAst,</span>
<span class="fc" id="L1461">                 visit(ctx.nonWildcardTypeArguments()));</span>
<span class="fc" id="L1462">        DetailAstPair.addAstChild(currentAst, visit(ctx.id()));</span>
<span class="fc" id="L1463">        final DetailAstImpl lparen = create(TokenTypes.METHOD_CALL,</span>
<span class="fc" id="L1464">                (Token) ctx.LPAREN().getPayload());</span>
<span class="fc" id="L1465">        DetailAstPair.makeAstRoot(currentAst, lparen);</span>

        // We always add an 'ELIST' node
<span class="fc" id="L1468">        final DetailAstImpl expressionList = Optional.ofNullable(visit(ctx.expressionList()))</span>
<span class="fc" id="L1469">                .orElseGet(() -&gt; createImaginary(TokenTypes.ELIST));</span>

<span class="fc" id="L1471">        DetailAstPair.addAstChild(currentAst, expressionList);</span>
<span class="fc" id="L1472">        DetailAstPair.addAstChild(currentAst, create(ctx.RPAREN()));</span>

<span class="fc" id="L1474">        return currentAst.root;</span>
    }

    @Override
    public DetailAstImpl visitInitExp(JavaLanguageParser.InitExpContext ctx) {
<span class="fc" id="L1479">        final DetailAstImpl dot = create(ctx.bop);</span>
<span class="fc" id="L1480">        dot.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1481">        final DetailAstImpl literalNew = create(ctx.LITERAL_NEW());</span>
<span class="fc" id="L1482">        literalNew.addChild(visit(ctx.nonWildcardTypeArguments()));</span>
<span class="fc" id="L1483">        literalNew.addChild(visit(ctx.innerCreator()));</span>
<span class="fc" id="L1484">        dot.addChild(literalNew);</span>
<span class="fc" id="L1485">        return dot;</span>
    }

    @Override
    public DetailAstImpl visitSimpleMethodCall(JavaLanguageParser.SimpleMethodCallContext ctx) {
<span class="fc" id="L1490">        final DetailAstImpl methodCall = create(TokenTypes.METHOD_CALL,</span>
<span class="fc" id="L1491">                (Token) ctx.LPAREN().getPayload());</span>
<span class="fc" id="L1492">        methodCall.addChild(visit(ctx.id()));</span>
        // We always add an 'ELIST' node
<span class="fc" id="L1494">        final DetailAstImpl expressionList = Optional.ofNullable(visit(ctx.expressionList()))</span>
<span class="fc" id="L1495">                .orElseGet(() -&gt; createImaginary(TokenTypes.ELIST));</span>

<span class="fc" id="L1497">        methodCall.addChild(expressionList);</span>
<span class="fc" id="L1498">        methodCall.addChild(create((Token) ctx.RPAREN().getPayload()));</span>
<span class="fc" id="L1499">        return methodCall;</span>
    }

    @Override
    public DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {
<span class="fc" id="L1504">        final DetailAstImpl lambda = create(ctx.LAMBDA());</span>
<span class="fc" id="L1505">        lambda.addChild(visit(ctx.lambdaParameters()));</span>

<span class="fc" id="L1507">        final JavaLanguageParser.BlockContext blockContext = ctx.block();</span>
        final DetailAstImpl rightHandLambdaChild;
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        if (blockContext != null) {</span>
<span class="fc" id="L1510">            rightHandLambdaChild = visit(blockContext);</span>
        }
        else {
            // Lambda expression child is built the same way that we build
            // the initial expression node in visitExpression, i.e. with
            // an imaginary EXPR node. This results in nested EXPR nodes
            // in the AST.
<span class="fc" id="L1517">            rightHandLambdaChild = buildExpressionNode(ctx.expr());</span>
        }
<span class="fc" id="L1519">        lambda.addChild(rightHandLambdaChild);</span>
<span class="fc" id="L1520">        return lambda;</span>
    }

    @Override
    public DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {
<span class="fc" id="L1525">        final DetailAstImpl bop = create(ctx.bop);</span>
<span class="fc" id="L1526">        bop.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1527">        bop.addChild(create(ctx.LITERAL_THIS()));</span>
<span class="fc" id="L1528">        return bop;</span>
    }

    @Override
    public DetailAstImpl visitPrimaryExp(JavaLanguageParser.PrimaryExpContext ctx) {
<span class="fc" id="L1533">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitPostfix(JavaLanguageParser.PostfixContext ctx) {
        final DetailAstImpl postfix;
<span class="fc bfc" id="L1539" title="All 2 branches covered.">        if (ctx.postfix.getType() == JavaLanguageLexer.INC) {</span>
<span class="fc" id="L1540">            postfix = create(TokenTypes.POST_INC, ctx.postfix);</span>
        }
        else {
<span class="fc" id="L1543">            postfix = create(TokenTypes.POST_DEC, ctx.postfix);</span>
        }
<span class="fc" id="L1545">        postfix.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1546">        return postfix;</span>
    }

    @Override
    public DetailAstImpl visitMethodRef(JavaLanguageParser.MethodRefContext ctx) {
<span class="fc" id="L1551">        final DetailAstImpl doubleColon = create(TokenTypes.METHOD_REF,</span>
<span class="fc" id="L1552">                (Token) ctx.DOUBLE_COLON().getPayload());</span>
<span class="fc" id="L1553">        final List&lt;ParseTree&gt; children = ctx.children.stream()</span>
<span class="fc bfc" id="L1554" title="All 2 branches covered.">                .filter(child -&gt; !child.equals(ctx.DOUBLE_COLON()))</span>
<span class="fc" id="L1555">                .collect(Collectors.toList());</span>
<span class="fc" id="L1556">        processChildren(doubleColon, children);</span>
<span class="fc" id="L1557">        return doubleColon;</span>
    }

    @Override
    public DetailAstImpl visitTernaryOp(JavaLanguageParser.TernaryOpContext ctx) {
<span class="fc" id="L1562">        final DetailAstImpl root = create(ctx.QUESTION());</span>
<span class="fc" id="L1563">        processChildren(root, ctx.children.stream()</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">                .filter(child -&gt; !child.equals(ctx.QUESTION()))</span>
<span class="fc" id="L1565">                .collect(Collectors.toList()));</span>
<span class="fc" id="L1566">        return root;</span>
    }

    @Override
    public DetailAstImpl visitBinOp(JavaLanguageParser.BinOpContext ctx) {
<span class="fc" id="L1571">        final DetailAstImpl bop = create(ctx.bop);</span>

        // To improve performance, we iterate through binary operations
        // since they are frequently deeply nested.
<span class="fc" id="L1575">        final List&lt;JavaLanguageParser.BinOpContext&gt; binOpList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1576">        ParseTree firstExpression = ctx.expr(0);</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        while (firstExpression instanceof JavaLanguageParser.BinOpContext) {</span>
            // Get all nested binOps
<span class="fc" id="L1579">            binOpList.add((JavaLanguageParser.BinOpContext) firstExpression);</span>
<span class="fc" id="L1580">            firstExpression = ((JavaLanguageParser.BinOpContext) firstExpression).expr(0);</span>
        }

<span class="fc bfc" id="L1583" title="All 2 branches covered.">        if (binOpList.isEmpty()) {</span>
<span class="fc" id="L1584">            final DetailAstImpl leftChild = visit(ctx.children.get(0));</span>
<span class="fc" id="L1585">            bop.addChild(leftChild);</span>
<span class="fc" id="L1586">        }</span>
        else {
            // Map all descendants to individual AST's since we can parallelize this
            // operation
<span class="fc" id="L1590">            final Queue&lt;DetailAstImpl&gt; descendantList = binOpList.parallelStream()</span>
<span class="fc" id="L1591">                    .map(this::getInnerBopAst)</span>
<span class="fc" id="L1592">                    .collect(Collectors.toCollection(ConcurrentLinkedQueue::new));</span>

<span class="fc" id="L1594">            bop.addChild(descendantList.poll());</span>
<span class="fc" id="L1595">            DetailAstImpl pointer = bop.getFirstChild();</span>
            // Build tree
<span class="fc bfc" id="L1597" title="All 2 branches covered.">            for (DetailAstImpl descendant : descendantList) {</span>
<span class="fc" id="L1598">                pointer.getFirstChild().addPreviousSibling(descendant);</span>
<span class="fc" id="L1599">                pointer = descendant;</span>
<span class="fc" id="L1600">            }</span>
        }

<span class="fc" id="L1603">        bop.addChild(visit(ctx.children.get(2)));</span>
<span class="fc" id="L1604">        return bop;</span>
    }

    /**
     * Builds the binary operation (binOp) AST.
     *
     * @param descendant the BinOpContext to build AST from
     * @return binOp AST
     */
    private DetailAstImpl getInnerBopAst(JavaLanguageParser.BinOpContext descendant) {
<span class="fc" id="L1614">        final DetailAstImpl innerBop = create(descendant.bop);</span>
<span class="fc" id="L1615">        final JavaLanguageParser.ExprContext expr = descendant.expr(0);</span>
<span class="fc bfc" id="L1616" title="All 2 branches covered.">        if (!(expr instanceof JavaLanguageParser.BinOpContext)) {</span>
<span class="fc" id="L1617">            innerBop.addChild(visit(expr));</span>
        }
<span class="fc" id="L1619">        innerBop.addChild(visit(descendant.expr(1)));</span>
<span class="fc" id="L1620">        return innerBop;</span>
    }

    @Override
    public DetailAstImpl visitMethodCall(JavaLanguageParser.MethodCallContext ctx) {
<span class="fc" id="L1625">        final DetailAstImpl methodCall = create(TokenTypes.METHOD_CALL,</span>
<span class="fc" id="L1626">                (Token) ctx.LPAREN().getPayload());</span>
        // We always add an 'ELIST' node
<span class="fc" id="L1628">        final DetailAstImpl expressionList = Optional.ofNullable(visit(ctx.expressionList()))</span>
<span class="fc" id="L1629">                .orElseGet(() -&gt; createImaginary(TokenTypes.ELIST));</span>

<span class="fc" id="L1631">        final DetailAstImpl dot = create(ctx.DOT());</span>
<span class="fc" id="L1632">        dot.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1633">        dot.addChild(visit(ctx.id()));</span>
<span class="fc" id="L1634">        methodCall.addChild(dot);</span>
<span class="fc" id="L1635">        methodCall.addChild(expressionList);</span>
<span class="fc" id="L1636">        methodCall.addChild(create((Token) ctx.RPAREN().getPayload()));</span>
<span class="fc" id="L1637">        return methodCall;</span>
    }

    @Override
    public DetailAstImpl visitTypeCastParameters(
            JavaLanguageParser.TypeCastParametersContext ctx) {
<span class="fc" id="L1643">        final DetailAstImpl typeType = visit(ctx.typeType(0));</span>
<span class="fc bfc" id="L1644" title="All 2 branches covered.">        for (int i = 0; i &lt; ctx.BAND().size(); i++) {</span>
<span class="fc" id="L1645">            addLastSibling(typeType, create(TokenTypes.TYPE_EXTENSION_AND,</span>
<span class="fc" id="L1646">                                (Token) ctx.BAND(i).getPayload()));</span>
<span class="fc" id="L1647">            addLastSibling(typeType, visit(ctx.typeType(i + 1)));</span>
        }
<span class="fc" id="L1649">        return typeType;</span>
    }

    @Override
    public DetailAstImpl visitSingleLambdaParam(JavaLanguageParser.SingleLambdaParamContext ctx) {
<span class="fc" id="L1654">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitFormalLambdaParam(JavaLanguageParser.FormalLambdaParamContext ctx) {
<span class="fc" id="L1659">        final DetailAstImpl lparen = create(ctx.LPAREN());</span>

        // We add an 'PARAMETERS' node here whether it exists or not
<span class="fc" id="L1662">        final DetailAstImpl parameters = Optional.ofNullable(visit(ctx.formalParameterList()))</span>
<span class="fc" id="L1663">                .orElseGet(() -&gt; createImaginary(TokenTypes.PARAMETERS));</span>
<span class="fc" id="L1664">        addLastSibling(lparen, parameters);</span>
<span class="fc" id="L1665">        addLastSibling(lparen, create(ctx.RPAREN()));</span>
<span class="fc" id="L1666">        return lparen;</span>
    }

    @Override
    public DetailAstImpl visitMultiLambdaParam(JavaLanguageParser.MultiLambdaParamContext ctx) {
<span class="fc" id="L1671">        final DetailAstImpl lparen = create(ctx.LPAREN());</span>
<span class="fc" id="L1672">        addLastSibling(lparen, visit(ctx.multiLambdaParams()));</span>
<span class="fc" id="L1673">        addLastSibling(lparen, create(ctx.RPAREN()));</span>
<span class="fc" id="L1674">        return lparen;</span>
    }

    @Override
    public DetailAstImpl visitMultiLambdaParams(JavaLanguageParser.MultiLambdaParamsContext ctx) {
<span class="fc" id="L1679">        final DetailAstImpl parameters = createImaginary(TokenTypes.PARAMETERS);</span>
<span class="fc" id="L1680">        parameters.addChild(createLambdaParameter(ctx.id(0)));</span>

<span class="fc bfc" id="L1682" title="All 2 branches covered.">        for (int i = 0; i &lt; ctx.COMMA().size(); i++) {</span>
<span class="fc" id="L1683">            parameters.addChild(create(ctx.COMMA(i)));</span>
<span class="fc" id="L1684">            parameters.addChild(createLambdaParameter(ctx.id(i + 1)));</span>
        }
<span class="fc" id="L1686">        return parameters;</span>
    }

    /**
     * Creates a 'PARAMETER_DEF' node for a lambda expression, with
     * imaginary modifier and type nodes.
     *
     * @param ctx the IdContext to create imaginary nodes for
     * @return DetailAstImpl of lambda parameter
     */
    private DetailAstImpl createLambdaParameter(JavaLanguageParser.IdContext ctx) {
<span class="fc" id="L1697">        final DetailAstImpl ident = visitId(ctx);</span>
<span class="fc" id="L1698">        final DetailAstImpl parameter = createImaginary(TokenTypes.PARAMETER_DEF);</span>
<span class="fc" id="L1699">        final DetailAstImpl modifiers = createImaginary(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L1700">        final DetailAstImpl type = createImaginary(TokenTypes.TYPE);</span>
<span class="fc" id="L1701">        parameter.addChild(modifiers);</span>
<span class="fc" id="L1702">        parameter.addChild(type);</span>
<span class="fc" id="L1703">        parameter.addChild(ident);</span>
<span class="fc" id="L1704">        return parameter;</span>
    }

    @Override
    public DetailAstImpl visitParenPrimary(JavaLanguageParser.ParenPrimaryContext ctx) {
<span class="fc" id="L1709">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitTokenPrimary(JavaLanguageParser.TokenPrimaryContext ctx) {
<span class="fc" id="L1714">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitClassRefPrimary(JavaLanguageParser.ClassRefPrimaryContext ctx) {
<span class="fc" id="L1719">        final DetailAstImpl dot = create(ctx.DOT());</span>
<span class="fc" id="L1720">        final DetailAstImpl primaryTypeNoArray = visit(ctx.type);</span>
<span class="fc" id="L1721">        dot.addChild(primaryTypeNoArray);</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">        if (TokenUtil.isOfType(primaryTypeNoArray, TokenTypes.DOT)) {</span>
            // We append '[]' to the qualified name 'TYPE' `ast
<span class="fc" id="L1724">            ctx.arrayDeclarator()</span>
<span class="fc" id="L1725">                    .forEach(child -&gt; primaryTypeNoArray.addChild(visit(child)));</span>
        }
        else {
<span class="fc" id="L1728">            ctx.arrayDeclarator()</span>
<span class="fc" id="L1729">                    .forEach(child -&gt; addLastSibling(primaryTypeNoArray, visit(child)));</span>
        }
<span class="fc" id="L1731">        dot.addChild(create(ctx.LITERAL_CLASS()));</span>
<span class="fc" id="L1732">        return dot;</span>
    }

    @Override
    public DetailAstImpl visitPrimitivePrimary(JavaLanguageParser.PrimitivePrimaryContext ctx) {
<span class="fc" id="L1737">        final DetailAstImpl dot = create(ctx.DOT());</span>
<span class="fc" id="L1738">        final DetailAstImpl primaryTypeNoArray = visit(ctx.type);</span>
<span class="fc" id="L1739">        dot.addChild(primaryTypeNoArray);</span>
<span class="fc" id="L1740">        ctx.arrayDeclarator().forEach(child -&gt; dot.addChild(visit(child)));</span>
<span class="fc" id="L1741">        dot.addChild(create(ctx.LITERAL_CLASS()));</span>
<span class="fc" id="L1742">        return dot;</span>
    }

    @Override
    public DetailAstImpl visitCreator(JavaLanguageParser.CreatorContext ctx) {
<span class="fc" id="L1747">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitCreatedNameObject(JavaLanguageParser.CreatedNameObjectContext ctx) {
<span class="fc" id="L1752">        final DetailAstPair currentAST = new DetailAstPair();</span>
<span class="fc" id="L1753">        DetailAstPair.addAstChild(currentAST, visit(ctx.annotations()));</span>
<span class="fc" id="L1754">        DetailAstPair.addAstChild(currentAST, visit(ctx.id()));</span>
<span class="fc" id="L1755">        DetailAstPair.addAstChild(currentAST, visit(ctx.typeArgumentsOrDiamond()));</span>

        // This is how we build the type arguments/ qualified name tree
<span class="fc bfc" id="L1758" title="All 2 branches covered.">        for (ParserRuleContext extendedContext : ctx.extended) {</span>
<span class="fc" id="L1759">            final DetailAstImpl dot = create(extendedContext.start);</span>
<span class="fc" id="L1760">            DetailAstPair.makeAstRoot(currentAST, dot);</span>
<span class="fc" id="L1761">            final List&lt;ParseTree&gt; childList = extendedContext</span>
<span class="fc" id="L1762">                    .children.subList(1, extendedContext.children.size());</span>
<span class="fc" id="L1763">            processChildren(dot, childList);</span>
<span class="fc" id="L1764">        }</span>

<span class="fc" id="L1766">        return currentAST.root;</span>
    }

    @Override
    public DetailAstImpl visitCreatedNamePrimitive(
            JavaLanguageParser.CreatedNamePrimitiveContext ctx) {
<span class="fc" id="L1772">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitInnerCreator(JavaLanguageParser.InnerCreatorContext ctx) {
<span class="fc" id="L1777">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitArrayCreatorRest(JavaLanguageParser.ArrayCreatorRestContext ctx) {
<span class="fc" id="L1782">        final DetailAstImpl arrayDeclarator = create(TokenTypes.ARRAY_DECLARATOR,</span>
<span class="fc" id="L1783">                (Token) ctx.LBRACK().getPayload());</span>
<span class="fc" id="L1784">        final JavaLanguageParser.ExpressionContext expression = ctx.expression();</span>
<span class="fc" id="L1785">        final TerminalNode rbrack = ctx.RBRACK();</span>
        // child[0] is LBRACK
<span class="fc bfc" id="L1787" title="All 2 branches covered.">        for (int i = 1; i &lt; ctx.children.size(); i++) {</span>
<span class="fc bfc" id="L1788" title="All 2 branches covered.">            if (ctx.children.get(i) == rbrack) {</span>
<span class="fc" id="L1789">                arrayDeclarator.addChild(create(rbrack));</span>
            }
<span class="fc bfc" id="L1791" title="All 2 branches covered.">            else if (ctx.children.get(i) == expression) {</span>
                // Handle '[8]', etc.
<span class="fc" id="L1793">                arrayDeclarator.addChild(visit(expression));</span>
            }
            else {
<span class="fc" id="L1796">                addLastSibling(arrayDeclarator, visit(ctx.children.get(i)));</span>
            }
        }
<span class="fc" id="L1799">        return arrayDeclarator;</span>
    }

    @Override
    public DetailAstImpl visitBracketsWithExp(JavaLanguageParser.BracketsWithExpContext ctx) {
<span class="fc" id="L1804">        final DetailAstImpl dummyRoot = new DetailAstImpl();</span>
<span class="fc" id="L1805">        dummyRoot.addChild(visit(ctx.annotations()));</span>
<span class="fc" id="L1806">        final DetailAstImpl arrayDeclarator =</span>
<span class="fc" id="L1807">                create(TokenTypes.ARRAY_DECLARATOR, (Token) ctx.LBRACK().getPayload());</span>
<span class="fc" id="L1808">        arrayDeclarator.addChild(visit(ctx.expression()));</span>
<span class="fc" id="L1809">        arrayDeclarator.addChild(create(ctx.stop));</span>
<span class="fc" id="L1810">        dummyRoot.addChild(arrayDeclarator);</span>
<span class="fc" id="L1811">        return dummyRoot.getFirstChild();</span>
    }

    @Override
    public DetailAstImpl visitClassCreatorRest(JavaLanguageParser.ClassCreatorRestContext ctx) {
<span class="fc" id="L1816">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitDiamond(JavaLanguageParser.DiamondContext ctx) {
<span class="fc" id="L1821">        final DetailAstImpl typeArguments =</span>
<span class="fc" id="L1822">                createImaginary(TokenTypes.TYPE_ARGUMENTS);</span>
<span class="fc" id="L1823">        typeArguments.addChild(create(TokenTypes.GENERIC_START,</span>
<span class="fc" id="L1824">                (Token) ctx.LT().getPayload()));</span>
<span class="fc" id="L1825">        typeArguments.addChild(create(TokenTypes.GENERIC_END,</span>
<span class="fc" id="L1826">                (Token) ctx.GT().getPayload()));</span>
<span class="fc" id="L1827">        return typeArguments;</span>
    }

    @Override
    public DetailAstImpl visitTypeArgs(JavaLanguageParser.TypeArgsContext ctx) {
<span class="fc" id="L1832">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitNonWildcardDiamond(
            JavaLanguageParser.NonWildcardDiamondContext ctx) {
<span class="fc" id="L1838">        final DetailAstImpl typeArguments =</span>
<span class="fc" id="L1839">                createImaginary(TokenTypes.TYPE_ARGUMENTS);</span>
<span class="fc" id="L1840">        typeArguments.addChild(create(TokenTypes.GENERIC_START,</span>
<span class="fc" id="L1841">                (Token) ctx.LT().getPayload()));</span>
<span class="fc" id="L1842">        typeArguments.addChild(create(TokenTypes.GENERIC_END,</span>
<span class="fc" id="L1843">                (Token) ctx.GT().getPayload()));</span>
<span class="fc" id="L1844">        return typeArguments;</span>
    }

    @Override
    public DetailAstImpl visitNonWildcardTypeArguments(
            JavaLanguageParser.NonWildcardTypeArgumentsContext ctx) {
<span class="fc" id="L1850">        final DetailAstImpl typeArguments = createImaginary(TokenTypes.TYPE_ARGUMENTS);</span>
<span class="fc" id="L1851">        typeArguments.addChild(create(TokenTypes.GENERIC_START, (Token) ctx.LT().getPayload()));</span>
<span class="fc" id="L1852">        typeArguments.addChild(visit(ctx.typeArgumentsTypeList()));</span>
<span class="fc" id="L1853">        typeArguments.addChild(create(TokenTypes.GENERIC_END, (Token) ctx.GT().getPayload()));</span>
<span class="fc" id="L1854">        return typeArguments;</span>
    }

    @Override
    public DetailAstImpl visitTypeArgumentsTypeList(
            JavaLanguageParser.TypeArgumentsTypeListContext ctx) {
<span class="fc" id="L1860">        final DetailAstImpl firstIdent = visit(ctx.typeType(0));</span>
<span class="fc" id="L1861">        final DetailAstImpl firstTypeArgument = createImaginary(TokenTypes.TYPE_ARGUMENT);</span>
<span class="fc" id="L1862">        firstTypeArgument.addChild(firstIdent);</span>

<span class="fc bfc" id="L1864" title="All 2 branches covered.">        for (int i = 0; i &lt; ctx.COMMA().size(); i++) {</span>
<span class="fc" id="L1865">            addLastSibling(firstTypeArgument, create(ctx.COMMA(i)));</span>
<span class="fc" id="L1866">            final DetailAstImpl ident = visit(ctx.typeType(i + 1));</span>
<span class="fc" id="L1867">            final DetailAstImpl typeArgument = createImaginary(TokenTypes.TYPE_ARGUMENT);</span>
<span class="fc" id="L1868">            typeArgument.addChild(ident);</span>
<span class="fc" id="L1869">            addLastSibling(firstTypeArgument, typeArgument);</span>
        }
<span class="fc" id="L1871">        return firstTypeArgument;</span>
    }

    @Override
    public DetailAstImpl visitTypeList(JavaLanguageParser.TypeListContext ctx) {
<span class="fc" id="L1876">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitTypeType(JavaLanguageParser.TypeTypeContext ctx) {
<span class="fc" id="L1881">        final DetailAstImpl type = createImaginary(TokenTypes.TYPE);</span>
<span class="fc" id="L1882">        processChildren(type, ctx.children);</span>

        final DetailAstImpl returnTree;
<span class="fc bfc" id="L1885" title="All 2 branches covered.">        if (ctx.createImaginaryNode) {</span>
<span class="fc" id="L1886">            returnTree = type;</span>
        }
        else {
<span class="fc" id="L1889">            returnTree = type.getFirstChild();</span>
        }
<span class="fc" id="L1891">        return returnTree;</span>
    }

    @Override
    public DetailAstImpl visitArrayDeclarator(JavaLanguageParser.ArrayDeclaratorContext ctx) {
<span class="fc" id="L1896">        final DetailAstImpl arrayDeclarator = create(TokenTypes.ARRAY_DECLARATOR,</span>
<span class="fc" id="L1897">                (Token) ctx.LBRACK().getPayload());</span>
<span class="fc" id="L1898">        arrayDeclarator.addChild(create(ctx.RBRACK()));</span>

        final DetailAstImpl returnTree;
<span class="fc" id="L1901">        final DetailAstImpl annotations = visit(ctx.anno);</span>
<span class="fc bfc" id="L1902" title="All 2 branches covered.">        if (annotations == null) {</span>
<span class="fc" id="L1903">            returnTree = arrayDeclarator;</span>
        }
        else {
<span class="fc" id="L1906">            returnTree = annotations;</span>
<span class="fc" id="L1907">            addLastSibling(returnTree, arrayDeclarator);</span>
        }
<span class="fc" id="L1909">        return returnTree;</span>
    }

    @Override
    public DetailAstImpl visitPrimitiveType(JavaLanguageParser.PrimitiveTypeContext ctx) {
<span class="fc" id="L1914">        return create(ctx.start);</span>
    }

    @Override
    public DetailAstImpl visitTypeArguments(JavaLanguageParser.TypeArgumentsContext ctx) {
<span class="fc" id="L1919">        final DetailAstImpl typeArguments = createImaginary(TokenTypes.TYPE_ARGUMENTS);</span>
<span class="fc" id="L1920">        typeArguments.addChild(create(TokenTypes.GENERIC_START, (Token) ctx.LT().getPayload()));</span>
        // Exclude '&lt;' and '&gt;'
<span class="fc" id="L1922">        processChildren(typeArguments, ctx.children.subList(1, ctx.children.size() - 1));</span>
<span class="fc" id="L1923">        typeArguments.addChild(create(TokenTypes.GENERIC_END, (Token) ctx.GT().getPayload()));</span>
<span class="fc" id="L1924">        return typeArguments;</span>
    }

    @Override
    public DetailAstImpl visitSuperSuffixDot(JavaLanguageParser.SuperSuffixDotContext ctx) {
        final DetailAstImpl root;
<span class="fc bfc" id="L1930" title="All 2 branches covered.">        if (ctx.LPAREN() == null) {</span>
<span class="fc" id="L1931">            root = create(ctx.DOT());</span>
<span class="fc" id="L1932">            root.addChild(visit(ctx.id()));</span>
        }
        else {
<span class="fc" id="L1935">            root = create(TokenTypes.METHOD_CALL, (Token) ctx.LPAREN().getPayload());</span>

<span class="fc" id="L1937">            final DetailAstImpl dot = create(ctx.DOT());</span>
<span class="fc" id="L1938">            dot.addChild(visit(ctx.id()));</span>
<span class="fc" id="L1939">            root.addChild(dot);</span>

<span class="fc" id="L1941">            final DetailAstImpl expressionList = Optional.ofNullable(visit(ctx.expressionList()))</span>
<span class="fc" id="L1942">                    .orElseGet(() -&gt; createImaginary(TokenTypes.ELIST));</span>
<span class="fc" id="L1943">            root.addChild(expressionList);</span>

<span class="fc" id="L1945">            root.addChild(create(ctx.RPAREN()));</span>
        }

<span class="fc" id="L1948">        return root;</span>
    }

    @Override
    public DetailAstImpl visitArguments(JavaLanguageParser.ArgumentsContext ctx) {
<span class="fc" id="L1953">        final DetailAstImpl lparen = create(ctx.LPAREN());</span>

        // We always add an 'ELIST' node
<span class="fc" id="L1956">        final DetailAstImpl expressionList = Optional.ofNullable(visit(ctx.expressionList()))</span>
<span class="fc" id="L1957">                .orElseGet(() -&gt; createImaginary(TokenTypes.ELIST));</span>
<span class="fc" id="L1958">        addLastSibling(lparen, expressionList);</span>
<span class="fc" id="L1959">        addLastSibling(lparen, create(ctx.RPAREN()));</span>
<span class="fc" id="L1960">        return lparen;</span>
    }

    @Override
    public DetailAstImpl visitPattern(JavaLanguageParser.PatternContext ctx) {
<span class="fc" id="L1965">        final JavaLanguageParser.InnerPatternContext innerPattern = ctx.innerPattern();</span>
<span class="fc" id="L1966">        final ParserRuleContext primaryPattern = innerPattern.primaryPattern();</span>
<span class="fc" id="L1967">        final ParserRuleContext recordPattern = innerPattern.recordPattern();</span>
<span class="fc bfc" id="L1968" title="All 2 branches covered.">        final boolean isSimpleTypePattern = primaryPattern != null</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">                &amp;&amp; primaryPattern.getChild(0) instanceof JavaLanguageParser.TypePatternContext;</span>

        final DetailAstImpl pattern;

<span class="fc bfc" id="L1973" title="All 2 branches covered.">        if (recordPattern != null) {</span>
<span class="fc" id="L1974">            pattern = visit(recordPattern);</span>
        }
<span class="fc bfc" id="L1976" title="All 2 branches covered.">        else if (isSimpleTypePattern) {</span>
            // For simple type pattern like 'Integer i`, we do not add `PATTERN_DEF` parent
<span class="fc" id="L1978">            pattern = visit(primaryPattern);</span>
        }
        else {
<span class="fc" id="L1981">            pattern = createImaginary(TokenTypes.PATTERN_DEF);</span>
<span class="fc" id="L1982">            pattern.addChild(visit(ctx.getChild(0)));</span>
        }
<span class="fc" id="L1984">        return pattern;</span>
    }

    @Override
    public DetailAstImpl visitInnerPattern(JavaLanguageParser.InnerPatternContext ctx) {
<span class="fc" id="L1989">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitGuardedPattern(JavaLanguageParser.GuardedPatternContext ctx) {
<span class="fc" id="L1994">        final DetailAstImpl guardAstNode = flattenedTree(ctx.guard());</span>
<span class="fc" id="L1995">        guardAstNode.addChild(visit(ctx.primaryPattern()));</span>
<span class="fc" id="L1996">        guardAstNode.addChild(visit(ctx.expr()));</span>
<span class="fc" id="L1997">        return guardAstNode;</span>
    }

    @Override
    public DetailAstImpl visitParenPattern(JavaLanguageParser.ParenPatternContext ctx) {
<span class="fc" id="L2002">        final DetailAstImpl lparen = create(ctx.LPAREN());</span>
<span class="fc" id="L2003">        final ParseTree innerPattern = ctx.getChild(1);</span>
<span class="fc" id="L2004">        lparen.addChild(visit(innerPattern));</span>
<span class="fc" id="L2005">        lparen.addChild(create(ctx.RPAREN()));</span>
<span class="fc" id="L2006">        return lparen;</span>
    }

    @Override
    public DetailAstImpl visitRecordPatternDef(JavaLanguageParser.RecordPatternDefContext ctx) {
<span class="fc" id="L2011">        return flattenedTree(ctx);</span>
    }

    @Override
    public DetailAstImpl visitTypePattern(
            JavaLanguageParser.TypePatternContext ctx) {
<span class="fc" id="L2017">        final DetailAstImpl type = visit(ctx.type);</span>
<span class="fc" id="L2018">        final DetailAstImpl patternVariableDef = createImaginary(TokenTypes.PATTERN_VARIABLE_DEF);</span>
<span class="fc" id="L2019">        patternVariableDef.addChild(createModifiers(ctx.mods));</span>
<span class="fc" id="L2020">        patternVariableDef.addChild(type);</span>
<span class="fc" id="L2021">        patternVariableDef.addChild(visit(ctx.id()));</span>
<span class="fc" id="L2022">        return patternVariableDef;</span>
    }

    @Override
    public DetailAstImpl visitRecordPattern(JavaLanguageParser.RecordPatternContext ctx) {
<span class="fc" id="L2027">        final DetailAstImpl recordPattern = createImaginary(TokenTypes.RECORD_PATTERN_DEF);</span>
<span class="fc" id="L2028">        recordPattern.addChild(createModifiers(ctx.mods));</span>
<span class="fc" id="L2029">        processChildren(recordPattern,</span>
<span class="fc" id="L2030">                ctx.children.subList(ctx.mods.size(), ctx.children.size()));</span>
<span class="fc" id="L2031">        return recordPattern;</span>
    }

    @Override
    public DetailAstImpl visitRecordComponentPatternList(
            JavaLanguageParser.RecordComponentPatternListContext ctx) {
<span class="fc" id="L2037">        final DetailAstImpl recordComponents =</span>
<span class="fc" id="L2038">                createImaginary(TokenTypes.RECORD_PATTERN_COMPONENTS);</span>
<span class="fc" id="L2039">        processChildren(recordComponents, ctx.children);</span>
<span class="fc" id="L2040">        return recordComponents;</span>
    }

    @Override
    public DetailAstImpl visitPermittedSubclassesAndInterfaces(
            JavaLanguageParser.PermittedSubclassesAndInterfacesContext ctx) {
<span class="fc" id="L2046">        final DetailAstImpl literalPermits =</span>
<span class="fc" id="L2047">                create(TokenTypes.PERMITS_CLAUSE, (Token) ctx.LITERAL_PERMITS().getPayload());</span>
        // 'LITERAL_PERMITS' is child[0]
<span class="fc" id="L2049">        processChildren(literalPermits, ctx.children.subList(1, ctx.children.size()));</span>
<span class="fc" id="L2050">        return literalPermits;</span>
    }

    @Override
    public DetailAstImpl visitId(JavaLanguageParser.IdContext ctx) {
<span class="fc" id="L2055">        return create(TokenTypes.IDENT, ctx.start);</span>
    }

    /**
     * Builds the AST for a particular node, then returns a &quot;flattened&quot; tree
     * of siblings. This method should be used in rule contexts such as
     * {@code variableDeclarators}, where we have both terminals and non-terminals.
     *
     * @param ctx the ParserRuleContext to base tree on
     * @return flattened DetailAstImpl
     */
    private DetailAstImpl flattenedTree(ParserRuleContext ctx) {
<span class="fc" id="L2067">        final DetailAstImpl dummyNode = new DetailAstImpl();</span>
<span class="fc" id="L2068">        processChildren(dummyNode, ctx.children);</span>
<span class="fc" id="L2069">        return dummyNode.getFirstChild();</span>
    }

    /**
     * Adds all the children from the given ParseTree or JavaParserContext
     * list to the parent DetailAstImpl.
     *
     * @param parent the DetailAstImpl to add children to
     * @param children the list of children to add
     */
    private void processChildren(DetailAstImpl parent, List&lt;? extends ParseTree&gt; children) {
<span class="fc" id="L2080">        children.forEach(child -&gt; {</span>
<span class="fc bfc" id="L2081" title="All 2 branches covered.">            if (child instanceof TerminalNode) {</span>
                // Child is a token, create a new DetailAstImpl and add it to parent
<span class="fc" id="L2083">                parent.addChild(create((TerminalNode) child));</span>
            }
            else {
                // Child is another rule context; visit it, create token, and add to parent
<span class="fc" id="L2087">                parent.addChild(visit(child));</span>
            }
<span class="fc" id="L2089">        });</span>
<span class="fc" id="L2090">    }</span>

    /**
     * Create a DetailAstImpl from a given token and token type. This method
     * should be used for imaginary nodes only, i.e. 'OBJBLOCK -&amp;gt; OBJBLOCK',
     * where the text on the RHS matches the text on the LHS.
     *
     * @param tokenType  the token type of this DetailAstImpl
     * @return new DetailAstImpl of given type
     */
    private static DetailAstImpl createImaginary(int tokenType) {
<span class="fc" id="L2101">        final DetailAstImpl detailAst = new DetailAstImpl();</span>
<span class="fc" id="L2102">        detailAst.setType(tokenType);</span>
<span class="fc" id="L2103">        detailAst.setText(TokenUtil.getTokenName(tokenType));</span>
<span class="fc" id="L2104">        return detailAst;</span>
    }

    /**
     * Create a DetailAstImpl from a given token and token type. This method
     * should be used for literal nodes only, i.e. 'PACKAGE_DEF -&amp;gt; package'.
     *
     * @param tokenType the token type of this DetailAstImpl
     * @param startToken the first token that appears in this DetailAstImpl.
     * @return new DetailAstImpl of given type
     */
    private DetailAstImpl create(int tokenType, Token startToken) {
<span class="fc" id="L2116">        final DetailAstImpl ast = create(startToken);</span>
<span class="fc" id="L2117">        ast.setType(tokenType);</span>
<span class="fc" id="L2118">        return ast;</span>
    }

    /**
     * Create a DetailAstImpl from a given token. This method should be
     * used for terminal nodes, i.e. {@code LCURLY}, when we are building
     * an AST for a specific token, regardless of position.
     *
     * @param token the token to build the DetailAstImpl from
     * @return new DetailAstImpl of given type
     */
    private DetailAstImpl create(Token token) {
<span class="fc" id="L2130">        final int tokenIndex = token.getTokenIndex();</span>
<span class="fc" id="L2131">        final List&lt;Token&gt; tokensToLeft =</span>
<span class="fc" id="L2132">                tokens.getHiddenTokensToLeft(tokenIndex, JavaLanguageLexer.COMMENTS);</span>
<span class="fc" id="L2133">        final List&lt;Token&gt; tokensToRight =</span>
<span class="fc" id="L2134">                tokens.getHiddenTokensToRight(tokenIndex, JavaLanguageLexer.COMMENTS);</span>

<span class="fc" id="L2136">        final DetailAstImpl detailAst = new DetailAstImpl();</span>
<span class="fc" id="L2137">        detailAst.initialize(token);</span>
<span class="fc bfc" id="L2138" title="All 2 branches covered.">        if (tokensToLeft != null) {</span>
<span class="fc" id="L2139">            detailAst.setHiddenBefore(tokensToLeft);</span>
        }
<span class="fc bfc" id="L2141" title="All 2 branches covered.">        if (tokensToRight != null) {</span>
<span class="fc" id="L2142">            detailAst.setHiddenAfter(tokensToRight);</span>
        }
<span class="fc" id="L2144">        return detailAst;</span>
    }

    /**
     * Create a DetailAstImpl from a given TerminalNode. This method should be
     * used for terminal nodes, i.e. {@code @}.
     *
     * @param node the TerminalNode to build the DetailAstImpl from
     * @return new DetailAstImpl of given type
     */
    private DetailAstImpl create(TerminalNode node) {
<span class="fc" id="L2155">        return create((Token) node.getPayload());</span>
    }

    /**
     * Creates a type declaration DetailAstImpl from a given rule context.
     *
     * @param ctx ParserRuleContext we are in
     * @param type the type declaration to create
     * @param modifierList respective modifiers
     * @return type declaration DetailAstImpl
     */
    private DetailAstImpl createTypeDeclaration(ParserRuleContext ctx, int type,
                                                List&lt;? extends ParseTree&gt; modifierList) {
<span class="fc" id="L2168">        final DetailAstImpl typeDeclaration = createImaginary(type);</span>
<span class="fc" id="L2169">        typeDeclaration.addChild(createModifiers(modifierList));</span>
<span class="fc" id="L2170">        processChildren(typeDeclaration, ctx.children);</span>
<span class="fc" id="L2171">        return typeDeclaration;</span>
    }

    /**
     * Builds the modifiers AST.
     *
     * @param modifierList the list of modifier contexts
     * @return &quot;MODIFIERS&quot; ast
     */
    private DetailAstImpl createModifiers(List&lt;? extends ParseTree&gt; modifierList) {
<span class="fc" id="L2181">        final DetailAstImpl mods = createImaginary(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L2182">        processChildren(mods, modifierList);</span>
<span class="fc" id="L2183">        return mods;</span>
    }

    /**
     * Add new sibling to the end of existing siblings.
     *
     * @param self DetailAstImpl to add last sibling to
     * @param sibling DetailAstImpl sibling to add
     */
    private static void addLastSibling(DetailAstImpl self, DetailAstImpl sibling) {
<span class="fc" id="L2193">        DetailAstImpl nextSibling = self;</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">        if (nextSibling != null) {</span>
<span class="fc bfc" id="L2195" title="All 2 branches covered.">            while (nextSibling.getNextSibling() != null) {</span>
<span class="fc" id="L2196">                nextSibling = nextSibling.getNextSibling();</span>
            }
<span class="fc" id="L2198">            nextSibling.setNextSibling(sibling);</span>
        }
<span class="fc" id="L2200">    }</span>

    @Override
    public DetailAstImpl visit(ParseTree tree) {
<span class="fc" id="L2204">        DetailAstImpl ast = null;</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">        if (tree != null) {</span>
<span class="fc" id="L2206">            ast = tree.accept(this);</span>
        }
<span class="fc" id="L2208">        return ast;</span>
    }

    /**
     * Builds an expression node. This is used to build the root of an expression with
     * an imaginary {@code EXPR} node.
     *
     * @param exprNode expression to build node for
     * @return expression DetailAstImpl node
     */
    private DetailAstImpl buildExpressionNode(ParseTree exprNode) {
<span class="fc" id="L2219">        final DetailAstImpl expression = visit(exprNode);</span>

        final DetailAstImpl exprRoot;
<span class="fc bfc" id="L2222" title="All 2 branches covered.">        if (TokenUtil.isOfType(expression, EXPRESSIONS_WITH_NO_EXPR_ROOT)) {</span>
<span class="fc" id="L2223">            exprRoot = expression;</span>
        }
        else {
            // create imaginary 'EXPR' node as root of expression
<span class="fc" id="L2227">            exprRoot = createImaginary(TokenTypes.EXPR);</span>
<span class="fc" id="L2228">            exprRoot.addChild(expression);</span>
        }
<span class="fc" id="L2230">        return exprRoot;</span>
    }

    /**
     * Used to swap and organize DetailAstImpl subtrees.
     */
    private static final class DetailAstPair {

        /** The root DetailAstImpl of this pair. */
        private DetailAstImpl root;

        /** The child (potentially with siblings) of this pair. */
        private DetailAstImpl child;

        /**
         * Moves child reference to the last child.
         */
        private void advanceChildToEnd() {
<span class="fc bfc" id="L2248" title="All 2 branches covered.">            while (child.getNextSibling() != null) {</span>
<span class="fc" id="L2249">                child = child.getNextSibling();</span>
            }
<span class="fc" id="L2251">        }</span>

        /**
         * Returns the root node.
         *
         * @return the root node
         */
        private DetailAstImpl getRoot() {
<span class="fc" id="L2259">            return root;</span>
        }

        /**
         * This method is used to replace the {@code ^} (set as root node) ANTLR2
         * operator.
         *
         * @param pair the DetailAstPair to use for swapping nodes
         * @param ast the new root
         */
        private static void makeAstRoot(DetailAstPair pair, DetailAstImpl ast) {
<span class="fc" id="L2270">            ast.addChild(pair.root);</span>
<span class="fc" id="L2271">            pair.child = pair.root;</span>
<span class="fc" id="L2272">            pair.advanceChildToEnd();</span>
<span class="fc" id="L2273">            pair.root = ast;</span>
<span class="fc" id="L2274">        }</span>

        /**
         * Adds a child (or new root) to the given DetailAstPair.
         *
         * @param pair the DetailAstPair to add child to
         * @param ast the child to add
         */
        private static void addAstChild(DetailAstPair pair, DetailAstImpl ast) {
<span class="fc bfc" id="L2283" title="All 2 branches covered.">            if (ast != null) {</span>
<span class="fc bfc" id="L2284" title="All 2 branches covered.">                if (pair.root == null) {</span>
<span class="fc" id="L2285">                    pair.root = ast;</span>
                }
                else {
<span class="fc" id="L2288">                    pair.child.setNextSibling(ast);</span>
                }
<span class="fc" id="L2290">                pair.child = ast;</span>
            }
<span class="fc" id="L2292">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>